## 数据类型

### 概述

计算机程序中，每个值都有其对应的一种数据类型。而JavaScrip中支持的数据类型可以分为两类：基本数据类型和引用数据类型。其中基本数据类型有数值，字符串，布尔值，undefined和null。而引用数据类型有对象，数组和函数。

> 函数是处理数据的方法，JavaScript把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为JavaScript的函数式编程奠定了基础。

### 数据类型检测

JavaScript中有如下三种方式来确定某个值的数据类型：

* typeof运算符
* instanceof运算符
* `Object.prototype.toString()`方法

其中，typeof运算符主要用来检测基本数据类型，其缺点是无法检测数组和null。

```js
typeof null			//'object'
typeof [1]			//'object'
typeof /s/			//'object'
typeof undefined	//'undefined'
```

null的类型是object，这是历史原因造成的。1995年的JavaScript第一版，只设计了五种数据类型：对象、整数、浮点数、字符串和布尔值，没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，就一直没有修改。但是这并不能说null就属于对象，本质上它是一个类似undefined的特殊值。

因此更常用Object.prototype上的toString()方法来进行数据类型检测。

```javascript
Object.prototype.toString.apply([]);			//'[object Array]'
Object.prototype.toString.apply({});			//'[object Object]'
Object.prototype.toString.apply(undefined);		//'[object Undefined]'
Object.prototype.toString.apply(null);			//'[object Null]'   
```

### 可变与不可变

基本数据类型的值是不可变的，因此它们的比较是值的比较，只要值相等就会返回true；而引用数据类型是引用的比较，所以即使它们拥有相同的属性和属性值也是不相等的。

```javascript
var arr = ["a","b"];
var arr1 = arr;		//将arr变量的内容拷贝一份赋值给arr1变量，只不过这个内容是地址而已
arr1[1];			//"b"


function sum(a,b) {
	return a+b;
}
var mySum = sum;			//mySum和sum指向同一块内存
log(mySum(1,1));			//2	
log(sum(1,1));				//2
sum = null;					//mySum依旧指向被赋值的内存地址
log(mySum(1,1));			//2
log(sum(1,1));				//fn is not a function
```

> 数据都是放在内存中的，而内存分为两种：堆和栈，其中值类型保存在栈里面，堆存放的是引用类型。

### null和undefined

null和undefined都可以表示没有，含义非常相似。所以将一个变量赋值为undefined或null，语法效果几乎没有区别。既然含义和用法差不多，那么为什么还要设置两个这样的值？

这是因为1995年JavaScript诞生时，为了和Java一样，其实只是设计了null这一个值用来表示无。又根据C语言传统，null又可以自动转为0。但是JavaScript作者Brendan Eich觉的这样还不够，有如下两个原因：

* 其一：null像在Java中一样，被当成一个对象。但是作者认为表示无的值最好不要是对象
* 其二：JavaScript早期版本没有错误处理机制，所以当数据类型不匹配时，往往会自动转换类型或默默转换失败，作者认为如果null自动转换为0，很不容易发现错误。

因此，作者又设计了一个undefined。他是这样区分的：null是一个表示无的对象，转为数值时为0。undefined是一个表示无的原始值，转为数值时为NaN。但是这种区分方式在实践中很快被证明是不可行，目前这两个值基本是同义的，只存在一些细微的差别。

> 谷歌公司开发的JavaScript替代品Dart语言，就明确规定只有null，没有undefined。

目前，最好理解是：null表示空值，即该处的值现在为空。而undefined表示未定义，一般如下几个场景会返回undefined：

* 变量只声明，但是没有赋值
* 未传入实参的形参
* 未赋值的对象属性
* 函数的默认返回值或显式返回undefined

```javascript
var o = [1,2]
o = null
//当数组没有变量引用时，会自动被GC回收，以释放内存
```

> 如果变量准备将来用来保存对象，建议初始化为null。

### 布尔值

布尔值只有两个值，分别是true和false。如果JavaScript某个位置预期是布尔值，那么该位置上现有的值会自动转换为布尔值，转换规则是undefined，null，false，0，NaN和""(空字符串)都会转换为false，其余值转换为true。

### 数值

#### 整数和浮点数

JavaScript不区分整数和浮点数，所有的数字均用64位浮点数形式存储，所以会出现如下情况：

```javascript
1 === 1.0				//true
1 + 1.0					//2
```

这就是说，JavaScript语言的底层根本没有整数，所有数字都是小数，即64为浮点数。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数自动转成32位整数，然后再进行运算，例如数组索引。

另外，由于保存浮点数数值需要的内存空间是保存整数值的两倍，因此JavaScript也会不失时机地将浮点数值转换为整数值，所以浮点数1.0实际上会被解析为整数1。

浮点数的最高精度是17为小数，所以涉及小数的比较和运算都要十分小心：

```js
0.1 + 0.2 === 0.3		//false
0.3 / 0.1				// 2.9999999999999996
```

> 关于浮点数值计算会产生舍入误差的问题，这是使用基于IEEE754数值的浮点计算的通病，不是ES独此一家，使用相同数值格式的语言也有这个问题。

#### 数值精度

根据国际标准IEEE 754，JavaScript浮点数的64位二进制，从左到右分别表示如下：

- 第1位：表示符号位，0表示正数，1表示负数
- 第2~12位（共11位）：表示指数部分
- 第13~64位（共52位）：表示小数部分，即有效数字部分

因此，符号位决定了数值的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是`1.xx...xx`的形式，其中`xx..xx`的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。

```
(-1)^符号位 * 1.xx...xx * 2^指数部分
```

上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。

精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2^53到2^53，都可以精确表示。

```javascript
Math.pow(2, 53)
// 9007199254740992
 
Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996
```

上述代码中可以看出，大于2^53之后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。

```js
Math.pow(2, 53)
// 9007199254740992

// 多出的三个有效数字，将无法保存
9007199254740992111
// 9007199254740992000
```

上述代码中，大于2的53次方以后，多出来的有效数字，最后三位的111都会无法保存，变成0。

#### 数值范围

根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。

如果一个数大于等于2的1024次方，那么就会发生“正向溢出”（overflow），即 JavaScript 无法表示这么大的数，这时就会返回`Infinity`。

```js
Math.pow(2, 1024) // Infinity
```

如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”（underflow），即 JavaScript 无法表示这么小的数，这时会直接返回0。

```js
Math.pow(2, -1075) // 0
```

JavaScript提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。

```js
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
```

#### 数值表示法

JavaScript的数值有多种表示方法，可以直接使用字面量表示，也可以使用科学计数法表示。

```javascript
123e3			//123000
123E-3			//0.123
```

如下两种情况，JavaScript会自动将数值转换为科学计数法表示。

- 小数点前的数字多于32位
- 小数点后的零多于5位

#### 数值进制

当使用字面量表示整数数值时，JavaScript支持如下四种进制：

- 十进制：不是以`0`开头的数
- 八进制：以`0o`，`0O`开头的数，或以`0`开头并且只用到0~7之间的数。
- 十六进制：以`0x`或`0X`开头的数，后跟任何十六进制数字（0~9及A~F）。其中字母可以大写也可以小写
- 二进制：以`0b`或`0B`的数 

默认情况下，JavaScript会自动将八进制，十六进制和二进制转换为十进制。而如果这三个进制的数值里面，出现了不属于该进制的数字，就会报错

```javascript
0xff 			// 255
0o377 			// 255
0b11 			// 3
0xzz 			// 报错
0o88 			// 报错
0b22 			// 报错
077				//八进制
088				//十进制
```

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，,那么前导0会被忽略，后面的数值将被当做十进制数值解析。

所以当处理以`0`开头的八进制容易引起歧义，所以ES5的严格模式和ES6中都不支持这种表示法，但是目前部分浏览器还支持。

#### 特殊数值

##### 正零和负零

在JavaScript的64位浮点数中，左边第一位表示符号位，因此任何数都有其对应的负值，零也不例外。所以，JavaScript实际存在两个零，一个是`+0`，另一个是`-0`，并且它们是等价的。 

```javascript
-0 === +0 				// true
0 === -0 				// true
0 === +0 				// true
```

绝大部分情况下，正零和负零都可以当做普通零使用，除非它们作为分母，返回值才是不等价的。

```javascript
1 / 0				//+Infinity
1 / -0				//-Infinity
```

##### NaN

NaN(Not A Number)用来表示一个非数字，主要出现在字符串解析成数字出错的场合。

```javascript
1 - "a"				//NaN
Math.log(-1)		//NaN
0 / 0				//NaN
NaN - NaN			//NaN
NaN + 1				//NaN和任何值运算都是NaN，包括和自身
```

NaN不等于任何值，包括自身，根据这个特性可以判断一个值是否是NaN。当然还可以使用全局方法`isNaN`进行判断，但是该方法在进行判断时，会先将传入的参数转换为数字类型后再进行判断，所以这种方式并不可靠。

```javascript
NaN === NaN						//false
[NaN].indexOf(NaN)				//-1，indexOf()方法内部使用严格相等运算符
if(x !== x){
    console.log("x is a NaN")
}
isNaN(NaN)						//true
isNaN(true)						//false，等价于isNaN(Number(true))
isNaN({})						//true，等价于isNaN(Number({}))
isNaN([])						//false，等价于isNaN(Number([]))
```

##### Infinity

由于内存的限制，ES并不能保存世界上所有的数值。ES能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算结果超出JavaScript数值范围的值，那么该值会被自动转换成特殊的Infinity。

Infinity表示无穷，它有正负之分。其中，Infinity表示正无穷，-Infinity表示负无穷。

如下两种场景都会返回无穷

- 如果数值太大或者太小到无法表示
- 使用非0数值除以0

```javascript
Infinity === -Infinity				//false
Math.pow(2, Math.pow(2, 100))		//Infinity
0 / 0 								// NaN
1 / 0 								// Infinity
1 / -0								//-Infinity
```

> 由于数值正向溢出、负向溢出和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。

另外，Infinity大于一切数值(除了NaN)，-Infinity小于一切数值(除了NaN)。如果Infinity和NaN进行比较，总是返回false。

```javascript
Infinity > 1000 			// true
-Infinity < -1000 			// true
Infinity > NaN 				// false
-Infinity > NaN   			// false
Infinity < NaN 				// false
-Infinity < NaN 			// false
```

而关于Infinity的四则运算，可以总结为如下几种情况：

- 和普通数值进行计算，则符合无穷的计算规则

  ```javascript
  5 * Infinity 				// Infinity
  5 - Infinity 				// -Infinity
  Infinity / 5 				// Infinity
  5 / Infinity 				// 0
  ```

- 和0进行计算

  ```javascript
  0 * Infinity 				// NaN
  0 / Infinity 				// 0
  Infinity / 0 				// Infinity
  ```

- 和null进行计算，null会先转换为0，等同于和0进行计算

  ```javascript
  null * Infinity 			// NaN
  null / Infinity 			// 0
  Infinity / null 			// Infinity
  ```

- 和undefined进行计算，返回的都是NaN

  ```javascript
  undefined + Infinity // NaN
  undefined - Infinity // NaN
  undefined * Infinity // NaN
  undefined / Infinity // NaN
  Infinity / undefined // NaN
  ```

- 和Infinity进行计算

  ```javascript
  Infinity + Infinity 		// Infinity
  Infinity * Infinity 		// Infinity
  Infinity - Infinity 		// NaN
  Infinity / Infinity 		// NaN
  ```

另外，通过全局方法`isFinite()`可以判断一个值是否是正常值，如果是NaN，Infinity或-Infinity其中一个，则返回false。注意：该方法和`isNaN()`方法一样会先将传入的参数转换为数值后，再进行判断，所以并不可靠。

```javascript
isFinite(Infinity) 				// false
isFinite(-1) 					// true
isFinite(true) 					// true
isFinite(NaN) 					// false
isFinite("x")					//false，等价于isFinite(Number("x"))
```

> 访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负正infinity值。

#### 全局方法

##### parseInt()

`parseInt`方法用于将字符串转换为整数，如果传入的参数不是字符串，则会先转换为字符串后再进行操作。另外，在转换为整数的过程中，字符串中的字符会依次进行转换，如果遇到无法转换为数字的字符，就会停止转换过程，返回已经转好的部分。而如果遇到第一个字符就无法转换，则直接返回NaN。

```javascript
parseInt('123') 					// 123
parseInt('   81') 					// 81，自动将字符串头部的空格去除
parseInt(1.2)						//1，等价于parseInt("1.2")
parseInt('15e2') 					// 15
parseInt('15px') 					// 15
parseInt('abc') 					// NaN
parseInt('.3') 						// NaN
parseInt('') 						// NaN
parseInt('+')						// NaN
parseInt('+1')						// 1
parseInt(1000000000000000000000.5)	// 1
//会先将参数转换为科学计数法，然后转换为字符串，也就是最后等价于parseInt("1e+21")
parseInt(0.0000008) 				// 8
parseInt(0x11, 36) 					// 43
//会先将十六进制参数转换为十进制17，然后转换为字符串，也就是最后等价于parseInt("17",36)
parseInt(011, 2)					// NaN
//会先将八进制参数转换为十进制9，然后转换为字符串，也就是最后等价于parseInt("9",2)
parseInt("011",2)					//3
```

如果字符串以`0x`或`0X`开头，该方法会将其按照十六进制数解析。如果以`0`开头，将其按照十进制数解析。总之，`parseInt()`方法的返回值不是一个十进制整数，就是NaN。

```javascript
parseInt('0x10') 			// 16
parseInt('011')				// 11
```

ES3会把"011"当成八进制字面量，因此转换后的值是9，ES5的parseInt()已经不具备解析八进制的能力。为了消除不一致性，`parseInt()`方法还接收第二个可选参数(2~36之间)，表示被解析的值的进制，返回该值对应的十进制数。默认情况下，第二个参数为10，即默认十进制转换十进制。 

```javascript
parseInt('1000', 2) 		// 8	二进制1000转换为十进制
parseInt('1000', 6) 		// 216	六进制1000转换为十进制
parseInt('1000', 8) 		// 512
```

如果第二个参数不是数值，则会被自动转换为整数，但是这个整数只有在2~36之间才会得到有意义的结果。超过这个范围，则返回NaN。如果第二个参数是0，undefined和null，则直接忽略并以默认值进行运算。

```javascript
parseInt('1000', 2.1) 		//8
parseInt('10', 37) 			// NaN
parseInt('10', 1) 			// NaN
parseInt('10', 0) 			// 10
parseInt('10', null) 		// 10
parseInt('10', undefined) 	// 10
```

如果字符串中包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。

```javascript
parseInt('15', 2) 			// 1
parseInt('51', 2) 			// NaN
```

> 不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，建议在任何情况下都明确指定基数，即便是解析十进制。

##### parseFloat()

`parseFloat()`方法用于将一个字符串转换为浮点数。如果字符串符合科学计数法，则会进行相应的转换。而如果字符串中包含不能转换为浮点数的字符，则不再进行向后转换，返回已经转好的部分。若第一个字符就无法转换或者参数不是字符串，则直接返回NaN。

```javascript
parseFloat('314e-2') 			// 3.14
parseFloat('0.0314E+2') 		// 3.14
parseFloat('3.14more') 			// 3.14
parseFloat("f1.2") 				// NaN
parseFloat([]) 					// NaN
parseFloat("")					//NaN
parseFloat("2.1.2")				//2.1
```

和`parseInt()`方法一样，该方法同样会自动过滤字符串前导的空白字符。

```javascript
parseFloat('\t\v\r12.34 2') 	// 12.34
```

### 字符串

#### 概述

##### 定义

字符串是零个或多个16位Unicode字符组成的且用单引号或双引号引起的字符序列。但是如果要在单引号字符串的内部使用单引号或者在双引号字符串的内部使用双引号，就必须使用`\`反斜杠转义。注意： 由于HTML中的属性值使用双引号，所以建议JavaScript中的字符串只使用单引号。

```javascript
"a\"c"		
'a\'c'	
```

在ES3中，字符串直接量必须写在一行上，如果分开写就会抛出错误。但是在ES5中，可以使用`\`分行写。注意：反斜杠后面必须是换行符，而不能有其它字符(例如空格)，否则就会报错。

```javascript
'a
c'				// SyntaxError: Unexpected token ILLEGAL
'a \
c'				//'a c'
```

##### 转义

反斜杠在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。常见的需要转义的字符有如下：

* `\0` ：null(`\u0000`)
* `\b`： 后退键(`\u0008`) 
* `\f`： 换页符(`\u000C`)
* `\n`： 换行符(`\u000A`)
* `\r`： 回车键(`\u000D`)
* `\t`： 制表符(`\u0009`)
* `\v`： 垂直制表符(`\u000B`)
* `\'`： 单引号(`\u0027`)
* `\"`： 双引号(`\u0022`)
* `\\`：反斜杠(`\u005C`)

反斜杠还有如下三个特殊用法：

* `\HHH`：反斜杠后面紧跟三个八进制数(`000`到`377`)，表示一个字符。其中`HHH`对于该字符的Unicode码点。显然这种方式只能输出256(`4*8*8`)种字符。
* `\xHH`：`\x`后面紧跟两个十六进制数(`00`到`FF`)，表示一个字符。其中`HH`对应该字符的Unicode码点。显然这种方式只能输出256(`16*16`)种字符。注意：ASCII码字符可以用这种形式表示。
* `\uXXXX`： `\u`后面紧跟四个十六进制数(`0000`到`FFFF`)，表示一个字符。其中`HHHH`对应该字符的Unicode码点。注意：Unicode字符可以用这种形式表示。

```javascript
'\251' 				// "©"
'\xA9' 				// "©"
'\u00A9'		  	// "©"
```

如果在非特殊字符前使用反斜杠，那么它会被省略。

```javascript
'\a'				// "a"
```

##### 字符串与数组

ES5中，字符串可以被视为只读字符数组，因此可以使用`[]`运算符来返回某个位置的字符。如果方括号中的数字超过字符串的长度，或者根本不是数字，则返回undefined。

```javascript
"hello"[1]			//"h"
"hi"[5]				//undefined
"hi"[-1]			//"undefined"
"hi"['x']			//undefined
```

但是这仅仅限于获取而已，无法通过这个方法改变字符串内部的字符。

```javascript
var s = "hello"
s[1] = "s"			//不会报错，只是默认失败
s					//"hello"
```

另外，字符串也无法直接使用数组方法，必须通过call间接使用。不过，由于字符串是只读的，那么会改变原数组的方法(`push()`，`sort()`，`reverse()`，`splice()`等)都对字符串无效，只有将字符串转换为数组后才能使用。

##### length属性

确定字符串的长度，就是确定包含的16位值的个数，用只读属性length获取。而如果字符串中包含双字节字符，那么length属性可能不会精确地返回字符串中的字符数目。

```javascript
var s = 'hello'
s.length 				// 5
s.length = 3			//不会报错，只是默认失败
s.length 				//5
```

#### 字符集

JavaScript使用Unicode字符集，也就是说，在JavaScript引擎内部，所有字符都用Unicode表示。因此，JavaScript不仅以Unicode储存字符，还允许在程序中直接使用Unicode编号表示字符，即将字符写成`\uxxxx`的形式，其中`xxxx`表示该字符对应的Unicode编码。

```javascript
'\u00A9'		  				// "©"
```

解析代码的时候，JavaScript引擎会自动识别一个字符是字面量形式表示，还是Unicode形式表示。当输出给用户时，所有字符都会转成字面形式。

```javascript
var f\u006F\u006F = 'abc'
foo 							// "abc"
```

另外，每个字符在JavaScript内部都是以16位(两个字节)的UTF-16格式存储。也就是说，JavaScript的单位字符长度固定为16位长度，即两个字节。

但是，UTF-16有两种长度：对于`U+0000`到`U+FFFF`之间的字符，长度为16位。而对于`U+10000`到`U+10FFFF`之间的字符，长度为32位，即四个字节。并且前两个字节在`0xD800`到`0xDBFF`之间，后两个字节在`0xDC00`到`0xDFFFF`之间。

```javascript
var s = '\uD834\uDF06'
s 							// "𝌆"，浏览器会正确识别
s.length 					// 2，但是在JavaScript内部视为两个字符
/^.$/.test(s) 				// false
s.charAt(0) 				// ""
s.charAt(1) 				// ""
s.charCodeAt(0) 			// 55348
s.charCodeAt(1) 			// 57094
```

JavaScript对UTF-16的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为JavaScript第一版发布的时候，Unicode的码点只编导U+FFFF，因此两字节足够表示了。后来，Unicode纳入的字符越来越多，出现了四字节的编码。但是JavaScript的标准此时已经定型了，统一将字符限制在两字节，导致无法识别四字节的字符。所以例如：`U+1D306`对应的字符是`𝌆`，它写成UTF-16就是`0xD834 0xDF06`。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，，它无法识别，总是认为这是两个字符。

上述结果表明，对于在`U+10000`到`U+10FFFF`之间的字符，JavaScript总是视为两个字符。其中，用来匹配单个字符的正则表达式会失败，`charAt()`方法无法返回单个字符，`charCodeAt()`方法返回每个字节对应的十进制值。 总之，在处理字符串时，必须把这点考虑在内。

> JavaScript预定义的字符串操作方法均作用于16位值，并非单个字符。
>

#### 字符串方法

字符串对象和字符串直接量都是不可变的。因此像String.prototype上继承的方法，是不会改变破坏原字符串，都会生成一个新的字符串对象然后将其返回。之后将会了解Array.prototype上拥有很多破坏性方法。一般来说，非破坏性方法效率高些，而非破坏性方法效率低些。

##### fromCharCode()

该方法是String对象提供的静态方法(即定义在对象本身，而不是定义在对象实例的方法)。fromCharCode()方法的参数是一系列Unicode码点，返回其对应的字符串。

```javascript
String.fromCharCode(104, 101, 108, 108, 111)	// "hello"
```

此外，该方法不支持Unicode码点大于`0xFFFF`的字符，即传入的参数不能大于`0xFFFF`。 

```javascript
String.fromCharCode(0x20BB7)		// "ஷ"
```

上述代码返回的字符编号并不是`0x20BB7`，而是`0x0BB7`。造成这种结果的原因在于码点大于`0xFFFF`的字符占用四个字节，而JavaScript只支持两个字节的字符，在这种情况下，必须把`0x20BB7`拆成两个字符表示。

```javascript
String.fromCharCode(0xD842, 0xDFB7)	// "𠮷"
```

上述代码将`0x20BB7`拆成两个字符`0xD842`和`0xDFB7`就能得到正确的结果。此外，码点大于`0xFFFF`的字符的四字节表示法，由UTF-16编码方法决定。

##### charAt()

获取指定位置的字符，从索引0开始。如果指定位置小于0或者大于字符串的长度，则返回空字符串。

```javascript
var str = "hellworld";
str.charAt(2);		//"l"
str[2];				//"l"，可以用数组下标替代
str.charAt(100);	//""
```

##### charCodeAt()

获取指定位置上的字符编码(十进制表示的Unicode码点)，从索引0开始。如果指定位置小于0或者大于字符串的长度，则返回NaN。注意：该方法相当于fromCharCode()的逆操作。

```javascript

var str = "helloworld";
str.charCodeAt();				//省略参数则返回首字符的Unicode码点
str.charCodeAt(0);				//104
str.charCodeAt(100);			//NaN
104["toString"](16);			//"68"，转换为十六进制
String.fromCharCode(0x0068);	//"h"
```

此外，charCodeAt()方法返回的Unicode码点不大于65536(0xFFFF)，也就是说只返回两个字节的字符的码点。如果遇到Unicode码点大于65536的字符，必须连续使用两次charCodeAt()，不仅读入charCodeAt(i)，还要读入`charCodeAt(i+1)`，将两个16字节放在一起，才能得到准确的字符。

##### indexOf()

返回第一个字符串参数在调用该方法的字符串中第一次出现的索引，从第二个指定参数位置开始搜索。如果未能匹配成功，则返回-1。注意：该方法第二个可选参数可以是任意整数，默认值为0。如果传入的参数小于0，则查找整个字符串，相当于传入了0。而如果大于字符串的长度，则直接返回-1，除非被查找的字符串是一个空字符串，此时就返回字符串的长度。

```javascript
var str = "helloworld"
str.indexOf("wo")		//5
str.indexOf("wr")		//-1
str.indexOf("h",-1)		//0
str.indexOf("o")		//4
str.indexOf("o",5)		//6
str.indexOf("o",15)		//-1
str.indexOf("",15)		//10
```

##### lastIndexOf()

返回第一个字符串参数在调用该方法的字符串中最后一次出现的索引。如果未能匹配成功，则返回-1。注意：该方法从字符串的后面向前查找，从第二个指定参数参数位置开始。

该方法的第二个可选参数可以是任意整数，默认是字符串的长度。如果为负值，则被看作为0。如果大于字符串的长度，则被看作为字符串的长度。

```javascript
var str = "helloworld"
str.lastIndexOf("wr")		//-1
str.lastIndexOf("o")		//6
str.lastIndexOf("o",-1)		//-1
str.lastIndexOf("o",15)		//6
```

##### split()

将字符串按照指定字符转换为数组，默认是逗号。第二个可选参数代表生成的数组成员的最大个数。

```javascript
var str1 = "1,2,3";
str1.split();		//[1,2,3]
str1.split(",",2);	//[1,2]
str1.split("x");	//["1,2,3"]
```

##### concat()

连接一个或者多个字符串，如果接受的参数不是字符串，会先将其转换为字符串后再进行拼接操作。注意：该方法很少使用，通常使用`+`运算符拼接字符串。 

```javascript
var str = "ni";
var str1 = "nanren";
str.concat("suan");				//"nisuan"
str.concat("suanshenme",str1);	//"nisuanshenmenanren"
```

##### slice()

slice()方法用来截取字符串。从第一个参数(包括)开始截取到第二个参数(不包括)。其中第二个参数省略代表截取到最后。并且两个参数都可以是负数，表示从倒数计算的指定位置开始截取。如果第一个参数大于第二个参数，则返回空字符串。

```javascript
var str = "nisuanshenme";
str.slice(1);		//"isuanshenme"
str.slice(1,2);		//'i'
str.slice(1,2,3);	//'i',忽略最后一个参数
str.slice(-3);		//"nme"
str.slice(3,1);		//""
```

##### substr()

该方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串从开始位置一直截取到最后。此外，第一个参数可以是负数，表示倒数计算的字符位置。但是如果第二个参数是负数，将被自动转换为0，因此会返回空字符串。

```javascript
var str = "nisuanshenme";
str.substr(1);		//"isuanshenme"
str.substr(1,2);	//"is"
str.substr(-1);		//"e"
str.substr(-2,2);	//"me"
str.substr(-2,3);	//"me",超出能截取的范围，会尽量截取但不会报错
str.substr(2,-3);	//""
```

##### substring()

该方法和slice()方法作用相同，都是从原字符串中取出子字符串并返回。但是substring()有些奇怪的特性，因此不建议使用该方法，而是优先使用slice()方法。

substring()方法的第一个参数表示子字符串的开始位置(包括)，第二个参数表示结束位置(不包括)。如果省略第二个参数，则表示从第一个参数位置截取到最后。而如果第二个参数大于第一个参数，该方法会自动更换两个参数的位置。注意：如果参数是负数，该方法会自动将负数转换为0后再进行截取操作。

```javascript
var str = "nisuanshenme";
str.substring(-1);		//"nisuanshenme"
str.substring(3,1);		//"is"
str.substring(4,-2);	//"nisu"，str.substring(4,0) => str.substring(0,4)
```

##### trim()

该非法用于去除字符串两端的空格。此外，该方法去除的不仅仅是空格，还包括制表符(`\t`、`\v`)，换行符(`\n`)和回车符(`\r`)，即所有空白字符。

```javascript
var str = " nisu annanren ";
str.trim();				//"nisu annanren"
'\r\nabc \t'.trim() 	// 'abc'
```

##### toLowerCase()/toUpperCase()

toUpperCase()将字符串全部转换为大写，toLowerCase()则是将字符串全部转换为小写。此外，这个方法也可以间接将布尔值或数组转换为大写字符串。

```javascript
String.prototype.toUpperCase.call(true)	// "TRUE"
"".toUpperCase.call(['a', 'b', 'c'])	// "A,B,C"
```

##### 总结

字符串直接量是没有方法的，在调用方法时就会将其隐式转换为其包装对象。举个栗子：

```javascript
var objs1 = new String("123");
var objs2 = new String("123");
objs1 == objs2 	//false
objs1 === objs2 //false，引用类型比较的是内存地址
objs1 + "" === objs2 + "" //true，转换为字符串直接量，而基本数据类型的比较是值的比较
objs1 + "" === objs2 	  //false，严格等于不会进行类型转换
objs1 + "" == objs2 	  //true， 非严格等于会进行隐式转换
```

#### Base64转码

有时，文本里面包含一些不可打印的符号，比如ASCII码0~31的符号都无法打印出来，这时可以使用Base64编码，将它们转成可以打印的字符。另一个场景，有时需要以文本格式传递二进制数据，那么也可以使用Base64编码。

所谓Base64是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、`+`和`/`这64个字符组成的可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。

JavaScript原生提供两个Base64相关方法：

* btoa()：该方法用于将字符串或二进制值转为Base64编码
* atob()：该方法用于将Base64编码转为原来的编码

```javascript
var string = 'Hello World!';
btoa(string) 					// "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') 		// "Hello World!"
```

但是这两个方法不适合非ASCII码的字符，会报错。

```javascript
btoa('你好')						// Uncaught DOMException
```

如果要将非ASCII码字符转为Base64编码，中间必须有一个转码过程。

```javascript
function b64Encode(str) {
  return btoa(encodeURIComponent(str))
}
function b64Decode(str) {
  return decodeURIComponent(atob(str))
}
b64Encode('你好') 							// "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') 		// "你好"
```

### 对象

#### 全局对象

当JavaScript引擎启动时，会创建一个全局对象，并且初始化一些全局属性，这些全局对象和全局属性可以直接使用。

- 全局属性：undefined，Infinity，NaN
- 全局函数，isNaN()、parseInt()、eval()等
- 构造函数，Date()、RegExp()、String()、Object()、Array()等
- 全局对象，Math、JSON等

在web浏览器中，这个全局对象就是Window，当然浏览器也会预定义一些宿主对象。

> ES标准中定义的对象行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如DOM和BOM中的对象，都属于宿主对象；它们是有宿主实现提供和定义的。而ES标准是不负责定义宿主对象。

#### 包装对象

所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的`Number`、`String`、`Boolean`三个原生对象。这三个原生对象可以把原始类型的值变成(包装成)其对应的对象。注意：null和undefined没有对应的包装对象。

```javascript
var o1 = new Number(1);
var o2 = new String('a');
var o3 = new Boolean(true);	
1 == o1;	//true
1 === o1;	//false
"a" == o2;	//true
"a" === o2;	//false，在比较基本类型和其对应的包装对象时，非严格等于返回true，严格等于返回false
typeof o1;	//"object"
typeof o2;	//"object"
typeof o3;	//"object"
if(new Boolean(false)){
    console.log("hi")		//"hi"
}
if(false){
    console.log("hi")		//无输出
}
//书写三个包装对象的实例过于繁琐，所以基本无人这样使用，并且可能还会带来上面的歧义
```

JavaScript设计包装对象的最大目的就是为了让对象覆盖所有类型值(除了null和undefined)，以便于基本类型值也可以方便的调用特定方法和属性。

```javascript
o1.__proto__ === Number.prototype;	//true
o1.valueOf();		//1
o2.valueOf();		//"a"
o3.valueOf();		//true，不同的包装对象所继承的valueOf()方法作用都是将其转换为对应的基本类型值
o1.toString(2) 		//"1"
o2.toString() 		//"a"
o3.toString() 		//"true"，不同的包装对象所继承的toString()方法作用都是返回其所对应的字符串形式
```

此外，JavaScript引擎遇到基本类型值直接调用方法和属性时，会先将基本类型值转换为其对应的包装对象，然后再调用对应的方法和属性，调用结束后立即销毁这个临时对象。注意：这个包装对象是只读的，无法修改。并且在实现上并不一定创建或销毁这个临时对象，但是整个过程看起来是这样。

```javascript
var s = "abc"
s.length;				//3
//相当于
var S = new String(s);	
//{0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
//可以看出字符串的包装看起来像是类数组对象
S.length;	
S = null;
//例子
var s1 = 'hi';
s1.x = 1;
s1.x;					//undefined，调用结束后立即销毁
var s2 = new String("hi");
s2.x = 1;
s2.x;					//1，显式创建的包装对象实例并不会自动销毁
```

上述代码中，字符串所对应的包装对象中有每个位置的值，有length属性，以及一个内部属性[[PromitiveValue]]来保存字符串原始值。注意：这个内部属性外部无法调用，仅供valueOf()和toString()这样的方法内部调用。

此外，`Number`、`String`和`Boolean`如果不作为构造函数调用(即调用时不加`new`)，常常用于将任意类型的值转化为对应的基本类型值(详细看类型转换章节)。

#### 内置对象

JavaScript中，常见的内置对象有Array，Date，Error等。

##### Date

Date对象是JavaScript原生的时间库，它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各一亿天（单位为毫秒）。

Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。注意：当作为普通函数调用时，即便带有参数，返回的还是当前时间。

```javascript
Date()					//"Sun Nov 12 2017 19:26:22 GMT+0800 (中国标准时间)"
Date(2000, 1, 1)		//"Sun Nov 12 2017 19:26:22 GMT+0800 (中国标准时间)"
typeof Date()			//"string"
typeof Date				//"function"
```

Date还可以作为构造函数使用(配合new)，返回一个Date对象的实例。如果未传入参数，则返回的就是代表当前时间的对象。

```javascript
var d = new Date()
typeof d					//"object"					
d.valueOf()					//1510486200738
d.toString()				//"Sun Nov 12 2017 19:30:10 GMT+0800 (中国标准时间)"
```

> Date实例有一个独特的地方。其他对象求值的时候，都是默认调用valueOf()方法，但是Date实例求值的时候，默认调用toString()方法。这导致Date实例求值返回的是一个字符串，代表该实例对应的时间。

实际上，Date作为构造函数使用可以接受多种时间格式的参数，用来自定义时间。

- 接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数，这意味着如果是Unix时间戳(单位为秒)作为参数，需要先乘以1000。

  ```javascript
  new Date(1128096000000).toString()		//"Sat Oct 01 2005 00:00:00 GMT+0800 (中国标准时间)"
  new Date(3600 * 24 * 1000).toString()	//"Fri Jan 02 1970 08:00:00 GMT+0800 (中国标准时间)"
  new Date(-3600 * 24 * 1000).toString()	//"Wed Dec 31 1969 08:00:00 GMT+0800 (中国标准时间)"
  //如果参数是负数，则表示1970年1月1日之前的时间
  ```

- 接受一个日期字符串作为参数，返回所对应的时间。这个日期字符串的完整格式是`month day, year hours:minutes:seconds`，比如`"December 5,2001 13:30:00"`。如果省略了小时、分钟或秒数，这些值会被设为0。

  ```javascript
  new Date('January 6, 2013').toString()	//"Sun Jan 06 2013 00:00:00 GMT+0800 (中国标准时间)"
  //实际上，所以可以被Date.parse()方法解析的日期字符串，都可以作为参数来自定义时间
  new Date('2013-2-15')
  new Date('2013/2/15')
  new Date('02/15/2013')
  new Date('2013-FEB-15')
  new Date('FEB, 15, 2013')
  new Date('FEB 15, 2013')
  new Date('Feberuary, 15, 2013')
  new Date('Feberuary 15, 2013')
  new Date('15 Feb 2013')
  new Date('15, Feberuary, 2013')
  ```

  注意：在ES5中，如果日期字符串采用连词线格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。

  ```javascript
  new Date('2014-01-01').toString()	//"Wed Jan 01 2014 08:00:00 GMT+0800 (中国标准时间)"
  new Date('2014-1-1').toString()		//"Wed Jan 01 2014 00:00:00 GMT+0800 (中国标准时间)"
  /*
  	第二行代码没有前导0，JavaScript引擎会假设用户处于本地时区，所以返回0点0分
  	第一行代码有前导0，即使以ISO格式表示日期，JavaScript引擎也会假设用户处于格林尼治国际标准
  	时的时区。
  	总之，对于YYYY-MM-DD格式的日期字符串，JavaScript引擎可能会将其当做ISO格式来解析，采用标准
  	时区作为计时标准。而对于其它格式的日期字符串，一律视为非ISO格式，采用本地时区作为计时标准
  */
  ```

- 接收多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，至少需要传入两个参数，即年和月，其它参数默认为0。因为如果只传入一个参数，Date对象会将其解释成毫秒数。

  这些参数的取值范围如下：

  * year：表示年份，一般四位数表示，如果写成两位数，则加上1990
  * month：表示月份，0表示一月，11表示十二月
  * date：表示日期，1到31
  * hour：表示小时，0到23
  * minute：表示分钟，0到59
  * second：表示秒钟，0到59
  * ms：表示毫秒，0到999

  其中，月份从0开始计算，天数从1开始计算。另外，除了日期默认为1，小时、分钟、秒钟和毫秒默认都是0。

  ```javascript
  new Date(2013, 0).toString()		//"Wed Jan 01 2003 00:00:00 GMT+0800 (中国标准时间)"
  new Date(2013, 0, 1).toString()		//"Wed Jan 01 2003 00:00:00 GMT+0800 (中国标准时间)"
  //如果参数超过了正常范围，会被自动折算。例如：如果月份是15，就折算为下一年的4月
  new Date(2003,15).toString()		//"Thu Apr 01 2004 00:00:00 GMT+0800 (中国标准时间)"
  //如果参数是负数，则表示扣去的时间
  new Date(2003,-1).toString()		//"Sun Dec 01 2002 00:00:00 GMT+0800 (中国标准时间)"
  //如果第一个年份参数是0~99，则自动加上1990.如果是负数，则表示公元前
  new Date(1,0).toString()			//"Tue Jan 01 1901 00:00:00 GMT+0800 (中国标准时间)"
  new Date(-1,0).toString()			//"Fri Jan 01 -001 00:00:00 GMT+0800 (中国标准时间)"
  ```

另外，日期对象上还定义了一些静态方法：

- `Date.now()`方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数(Unix时间戳乘以1000)。

  ```javascript
  Date.hasOwnProperty("now")		//true
  Date.now()						//1364026285194
  /*
  	如果需要比毫秒更精确的时间，可以使用window.performance.now()方法。该方法提供页面加载到命令
  	运行时的已经过去的时间，可以精确到千分之一毫秒。
  */
  window.performance.now()		//3163193.41
  ```

- `Date.parse()`方法用来解析日期字符串，返回距离1970年1月1日00:00:00的毫秒数。注意：标准的日期字符串格式应该完全符合RFC 2822和ISO 8061标准，即`YYYY-MM-DDTHH:mm:ss.sssZ`格式，其中`Z`表示时区。但是实际上，不符合标准的其它日期字符串也可以被解析。如果解析失败，就会返回NaN。

  ```javascript
  Date.parse('Aug 9, 1995')						//807897600000
  Date.parse('Mon, 25 Dec 1995 13:30:00 GMT')		//807897600000
  Date.parse('2011-10-10')						//807897600000
  Date.parse('xxx') 								// NaN
  ```

- `Date.UTC()`，该方法可以返回UTC时间，即世界标准时间。因为默认情况下，Date对象返回的都是当前时区的时间。该方法接受年、月、日等参数，返回当前距离1970年1月1日00:00:00 UTC的毫秒数。注意：该方法的参数用法和Date构造函数完全一致，例如月份从0开始计算，日期从1开始计算等。

  ```javascript
  Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])	//参数格式
  Date.UTC(2011, 0, 1, 2, 3, 4, 567)							//1293847384567
  ```

另外，Date实例对象上还定义了一些其它关于时间的方法，将这些方法分为如下四类：

- to类：这类方法可以从Date对象返回一个字符串，表示指定的时间。

  - `Date.prototype.toString()`方法返回一个完整的日期字符串。

    ```javascript
    var date = new Date()
    date.toString()			//"Sat Jan 06 2018 18:02:00 GMT+0800 (中国标准时间)"
    date					//Sat Jan 06 2018 18:02:00 GMT+0800 (中国标准时间)
    /*
    	因为toString()是默认的调用方法，所以直接读取Date对象实例，就相当于调用这个方法
    */
    ```

  - `Date.prototype.toUTCString()`方法返回对应的UTC时间，也就是比北京时间晚8个小时

    ```javascript
    new Date().toUTCString()	//"Sat, 06 Jan 2018 10:04:32 GMT"
    ```

  - `Date.prototype.toISOString()`方法返回对应时间的ISO8601写法。注意：该方法返回的总是UTC时区的时间。

    ```javascript
    new Date().toISOString()	//"2018-01-06T10:06:14.258Z"
    ```

  - `Date.prototype.toJSON()`方法返回一个符合JSON格式的ISO的日期字符串，与`Date.prototype.toISOString()`方法返回结果完全相同。

    ```javascript
    new Date().toJSON()			//"2018-01-06T10:06:14.258Z"
    ```

  - `Date.prototype.toDateString()`方法返回日期字符串。

    ```javascript
    new Date().toDateString()	//"Sat Jan 06 2018"
    ```

  - `Date.prototype.toTimeString()`方法返回时间字符串

    ```javascript
    new Date().toTimeString()	//"18:10:40 GMT+0800 (中国标准时间)"
    ```

  - `Date.prototype.toLocaleDateString()`方法返回一个代表当地日期写法的字符串

    ```javascript
    new Date().toLocaleDateString()		//"2018/1/6"
    /*
    	中文浏览器为："2018/1/6"
    	英文浏览器为："1/6/2008"
    */
    ```

  - `Date.prototype.toLocaleTimeString()`方法返回一个代表当地时间写法的字符串

    ```javascript
    new Date().toLocaleTimeString()		//"下午6:12:39"
    /*
    	中文版浏览器为："下午6:12:39"
    	英文版浏览器为："6:12:39 PM"
    */	
    ```

- get类：这类方法用于获取Date对象的日期和时间。

  - `getTime()`：返回距离1970年1月1日00:00:00的毫秒数，等同于`valueOf`方法。
  - `getDate()`：返回实例对象对应每个月的几号（从1开始）。
  - `getDay()`：返回星期几，星期日为0，星期一为1，以此类推。
  - `getYear()`：返回距离1900的年数。
  - `getFullYear()`：返回四位的年份。
  - `getMonth()`：返回月份（0表示1月，11表示12月）。
  - `getHours()`：返回小时（0-23）。
  - `getMilliseconds()`：返回毫秒（0-999）。
  - `getMinutes()`：返回分钟（0-59）。
  - `getSeconds()`：返回秒（0-59）。
  - `getTimezoneOffset()`：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素。

  ```javascript
  new Date().getTimezoneOffset()		//-480
  /*
  	即UTC时间减去当前时间，单位是分钟。所以-480表示当前时区比UTC早8个小时
  */
  ```

  上面这些get类方法都是返回当前时区的时间，而Date对象上还定义了这些方法对应的UTC版本，用来返回UTC时间。

  - `getUTCDate()`
  - `getUTCFullYear()`
  - `getUTCMonth()`
  - `getUTCDay()`
  - `getUTCHours()`
  - `getUTCMinutes()`
  - `getUTCSeconds()`
  - `getUTCMilliseconds()`

  ```javascript
  new Date(2018,1,6).getDate()		//6，当前时区，也就是东八区的1月6日
  new Date(2018,1,6).getUTCDate()		//5，UTC时区，因为晚八个小时，所以是1月5日
  ```

- set类：这类方法用于设置Date对象的日期和时间。

  - `setDate(date)`：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。
  - `setYear(year)`：设置距离1900年的年数。
  - `setFullYear(year [, month, date])`：设置四位年份。
  - `setHours(hour [, min, sec, ms])`：设置小时（0-23）。
  - `setMilliseconds()`：设置毫秒（0-999）。
  - `setMinutes(min [, sec, ms])`：设置分钟（0-59）。
  - `setMonth(month [, date])`：设置月份（0-11）。
  - `setSeconds(sec [, ms])`：设置秒（0-59）。
  - `setTime(milliseconds)`：设置毫秒时间戳。

  set类方法基本和get类方法一一对应，但是没有`setDay()`方法，因为星期几是计算出来的，而不是设置的。

  ```javascript
  var date = new Date()
  date.toString()				//"Sat Jan 06 2018 18:46:10 GMT+0800 (中国标准时间)"
  date.setDate(9)				//1515494770285
  date.toSTring()				//"Tue Jan 09 2018 18:46:10 GMT+0800 (中国标准时间)"
  ```

  另外，set类方法都会自动折算。例如：以`setDate()`方法为例，如果参数超过当月的最大天数，则向下一个月顺延。如果参数是负数，表示从上个月的最后一天开始减去的天数。

  ```javascript
  var date = new Date()
  date.toString()			//"Sat Jan 06 2018 19:12:04 GMT+0800 (中国标准时间)"
  date.setDate(20)		//1516446724353
  date.toString()			//"Sat Jan 20 2018 19:12:04 GMT+0800 (中国标准时间)"
  date.setDate(-1)		//1514632324353
  date.toString()			//"Sat Dec 30 2017 19:12:04 GMT+0800 (中国标准时间)"
  ```

  set类方法除了setTime()和setYear()之外，都有对应的UTC版本，即设置UTC时区的时间。

  - `setUTCDate()`
  - `setUTCFullYear()`
  - `setUTCHours()`
  - `setUTCMilliseconds()`
  - `setUTCMinutes()`
  - `setUTCMonth()`
  - `setUTCSeconds()`

- `Date.prototype.valueOf()`方法返回实例对象距离1970年1月1日00:00:00 UTC对应的毫秒数。

##### Error

JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。这个错误对象是`Error()`构造函数的实例，并且程序会中断在发生错误的地方，不再往下执行。

```javascript
var err = new Error('出错了');
err.message // "出错了"
```

`Error()`构造函数接收一个参数表示错误提示，可以从实例的`message`属性获取这个参数。此外，ES标准规定`Error`对象的实例必须有`message`属性，用来表示出错时的提示信息。当然，错误对象还有name和stack属性，分别表示错误的名称和错误的堆栈，但是这两个属性是非标准属性，并不是所有JavaScript实现都有。

```javascript
function throwit() {
  throw new Error('');
}
function catchit() {
  try {
    throwit();
  } catch(e) {
    console.log(e.stack); 
  }
}
catchit()
/* 
   Error
   at throwit (~/examples/throwcatch.js:9:11)
   at catchit (~/examples/throwcatch.js:3:9)
   at repl:1:5
   结果表明：抛出错误首先在throwit函数，然后是在catchit函数，最后是在函数的运行环境中
*/
```

此外，Error对象是最一般的错误类型，在它的基础上，JavaScript还定义了其它六种派生错误对象，它们分别是：

- SyntaxError，表示解析代码时发生的语法错误
- ReferenceError，表示引用一个不存在的变量时发生的错误或者是将一个值分配给无法分配的对象
- RangeError，表示当一个值超出有效范围时发生的错误。例如：数组长度为负数，Number对象的方法参数超出范围，或者函数堆栈超过最大值
- TypeError，表示变量或参数不是预期类型时发生的错误
- URIError，表示URI相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数
- EvalError，表示eval函数没有被正确执行时抛出的错误。注意：该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容才继续保留。

```javascript
var 1;			//SyntaxError
this = 1;		//ReferenceError
new Array(-1);	//RangeError
new 12;			//TypeError
decodeURI('%2')	//URIError
```

这六种派生错误对象，以及基本的Error对象都是构造函数，所以可以手动创建对应错误类型的实例。

```javascript
new RangeError('出错了，变量超出有效范围！');
new TypeError('出错了，变量类型无效！');
```

##### Number

Number对象拥有如下一些属性。

- `Number.POSITIVE_INFINITY`：正的无限，指向`Infinity`。
- `Number.NEGATIVE_INFINITY`：负的无限，指向`-Infinity`。
- `Number.NaN`：表示非数值，指向`NaN`。
- `Number.MAX_VALUE`：表示最大的正数，相应的，最小的负数为`-Number.MAX_VALUE`。
- `Number.MIN_VALUE`：表示最小的正数(即最接近0的正数，在64位浮点数体系中为`5e-324`)，相应的，最接近0的负数为`-Number.MIN_VALUE`。
- `Number.MAX_SAFE_INTEGER`：表示能够精确表示的最大整数，即`9007199254740991`。
- `Number.MIN_SAFE_INTEGER`：表示能够精确表示的最小整数，即`-9007199254740991`。

```javascript
Number.POSITIVE_INFINITY 	// Infinity
Number.NEGATIVE_INFINITY 	// -Infinity
Number.NaN 					// NaN
Number.MAX_VALUE			// 1.7976931348623157e+308
Number.MAX_VALUE < Infinity	// true
Number.MIN_VALUE			// 5e-324
Number.MIN_VALUE > 0		// true
Number.MAX_SAFE_INTEGER 	// 9007199254740991
Number.MIN_SAFE_INTEGER	  	// -9007199254740991
```

##### Math

Math是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象调用。

```javascript
new Math();		//TypeError
```

Math对象的静态属性大多用来表示只读的数学常数。

- `Math.E`：常数e。
- `Math.LN2`：2的自然对数。
- `Math.LN10`：10的自然对数。
- `Math.LOG2E`：以2为底的e的对数。
- `Math.LOG10E`：以10为底的e的对数。
- `Math.PI`：常数Pi。
- `Math.SQRT1_2`：0.5的平方根。
- `Math.SQRT2`：2的平方根。

```javascript
Math.E 			// 2.718281828459045
Math.LN2 		// 0.6931471805599453
Math.LN10 		// 2.302585092994046
Math.LOG2E 		// 1.4426950408889634
Math.LOG10E 	// 0.4342944819032518
Math.PI 		// 3.141592653589793
Math.SQRT1_2 	// 0.7071067811865476
Math.SQRT2 		// 1.4142135623730951
```

此外，Math对象上还定义了一些进行复杂数学运算的静态方法。

- `Math.abs()`：该方法返回参数值的绝对值
- `Math.ceil()`：该方法接受一个参数，返回大于该参数的最小整数，即向上取整
- `Math.floor()`：该方法接受一个参数，返回小于该参数的最大整数，即向下取整
- `Math.max()`：该方法可以接受多个参数，返回这些参数中的最大值
- `Math.min()`：该方法可以接受多个参数，返回这些参数中的最小值。有趣的是，Math.max()和Math.min()方法不传参会分别返回-Infinity和Infinity
- `Math.pow()`：该方法返回以第一个参数为底数、第二个参数为幂的指数值
- `Math.sqrt()`：该方法返回参数值的平方根，如果参数是一个负值，则返回NaN
- `Math.log()`：该方法返回以e为底的自然对数值。如果要计算以10为底的对数，可以先用`Math.log`求出自然对数，然后除以`Math.LN10`；求以2为底的对数，可以除以`Math.LN2`。
- `Math.exp()`：该方法返回常数e的参数次方
- `Math.round()`：该方法接受一个参数，返回该参数的四舍五入值。
- `Math.random()`：返回0~1之间的伪随机数，可能等于0，但是一定小于1。
- `Math.trunc()`：返回小数的整数部分，即去除小数点后面部分

```javascript
Math.abs(1) 		// 1
Math.abs(-1) 		// 1
Math.max(2, -1, 5) 	// 5
Math.min(2, -1, 5) 	// -1
Math.min() 			// Infinity
Math.max() 			// -Infinity
Math.floor(3.2) 	// 3
Math.floor(-3.2) 	// -4
Math.ceil(3.2) 		// 4
Math.ceil(-3.2) 	// -3
Math.round(0.1) 	// 0
Math.round(0.5) 	// 1
Math.round(0.6) 	// 1，该方法等同于Math.floor(x + 0.5)
Math.round(-1.1) 	// -1，注意该方法对负数的处理
Math.round(-1.5) 	// -1
Math.round(-1.6) 	// -2
Math.pow(2, 2) 		// 4
Math.sqrt(4) 		// 2
Math.sqrt(-4) 		// NaN
Math.log(Math.E) 	// 1
Math.log(10) 		// 2.302585092994046
Math.log(100)/Math.LN10 // 2
Math.log(8)/Math.LN2 	// 3
Math.exp(1) 		// 2.718281828459045
Math.exp(3) 		// 20.085536923187668
Math.random() 		// 0.7151307314634323
Math.floor(Math.random()*(33-23+1))+23		//获取23到33之间的随机数
Math.trunc(1.2)		//1
```

此外，Math对象上还定义了一系列三角函数方法。

- `Math.sin()`：返回参数的正弦
- `Math.cos()`：返回参数的余弦
- `Math.tan()`：返回参数的正切
- `Math.asin()`：返回参数的反正弦(弧度值)
- `Math.acos()`：返回参数的反余弦(弧度值)
- `Math.atan()`：返回参数的反正切(弧度值)

```javascript
Math.sin(0) 	// 0
Math.cos(0) 	// 1
Math.tan(0) 	// 0
Math.asin(1) 	// 1.5707963267948966
Math.acos(1) 	// 0
Math.atan(1) 	// 0.7853981633974483
```

### 运算符

#### 左值

左值是指表达式只能出现在赋值运算符的左侧。其中，变量、对象属性和数组元素均是左值。并且ES规范允许内置函数返回一个左值，但是自定义函数不能。

```javascript
function fn(){
  var a = 1;
  return a;
}
console.log(++fn()); //自定义函数无法返回左值
```

#### 算术运算符

JavaScript提供如下十个算术运算符，用来完成基本的算术运算。

* 加法运算符(`m+n`)
* 减法运算符(`m-n`)
* 乘法运算符(`m*n`)
* 除法运算符(`m/n`)
* 余数运算符(`m%n`)
* 自增运算符(`++m`或`m++`)
* 自减运算符(`--m`或`m--`)
* 数值运算符(`+m`)
* 负数值运算符(`-m`)
* 指数运算符(`m**n`)

##### 加法运算符

加法运算符既可以用来处理算术的加法，也可以用作字符串拼接。它的算法步骤如下：

- 如果运算子是对象，先自动转成原始类型的值，即先执行该对象的`valueOf()`方法。一般来说，对象的`valueOf()`方法返回对象自身，所以还不是原始类型的值，这时再调用对象的`toString()`方法，将其转换为字符串类型。注意：如果运算子是一个Date对象的实例，那么会优先执行`toString()`方法
- 两个运算子都是原始类型的值以后，只要其中一个运算子是字符串，则两个运算子都转为字符串，执行字符串连接操作
- 否则，两个运算子都转为数值，执行加法运算

另外，加法运算符还可以用来将一个值转为字符串，转换规则和Number()函数一样。

```javascript
x + ''			//"x"
```

注意：加法运算符是二元运算符，所以一定要有两个运算子。如果只有右边一个运算子，就是另一种数值运算符。而如果只有左边一个运算子，就会报错。

加法运算符是在运行时决定，到底是执行相加，还是执行字符串拼接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为重载（overload）。

除了加法运算符，其他算术运算符都不会发生重载，所有运算子一律转为数值后，再进行相应的数学运算。

##### 余数运算符

余数运算符返回前一个运算子被后一个运算子除所得的余数，但是由于运算结果的正负号由第一个运算子的正负号决定，所以常常需要使用绝对值以得到正确的负数的余数值。

```javascript
-1 % 2 			// -1
1 % -2 			// 1
```

余数运算符还可以用于浮点数的运算，但是由于浮点数不是精确的值，所以无法得到完全准确的结果。

```javascript
6.5 % 2.1			// 0.19999999999999973
```

##### 除法运算符

在JavaScript中，所有数字都是浮点型。因此`/`运算符的结果也是浮点型。并且当除数是0时，结果为+Infinity或者-Infinity；如果是0/0则返回NaN，但是这些运算都不会报错。

```javascript
5 / 2;	//2.5
```

模运算`/`的结果的符号和第一个操作数（被除数）的符号保持一致。例如，5%2结果是1，-5%2的结果是-1。模运算符(求余运算符)的操作数通常都是整数，但也适用于浮点数，比如，6.5%2.1结果是0.2。

##### 自增和自减运算符

自增和自减运算符都是一元运算符，该运算符会先将运算子转换为数值后，再进行运算。

> 自增自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

##### 数值运算符，负数值运算符

数值运算符是一元运算符，用于将任何值转为数值，与`Number()`函数作用相同。

```javascript
+true 		// 1
+[] 		// 0
+{} 		// NaN
```

负数值运算符也是一元运算符，同样会将值转换为其数值形式，只不过得到的值正负相反。因此，连用两个负数值运算符就等同于数值运算符。

```javascript
var x = 1;
-x 					// -1
-(-x) 				// 1，括号不能少，否则是自减运算符
```

> 这两个运算符都会返回一个新的值，而不会改变原始值。

#### 指数运算符

指数运算符用来完成指数运算，前一个运算子是底数，后一个运算子是指数。

```js
2 ** 3			//8
```

指数运算符是右结合，而不是左结合。

```js
2 ** 3 ** 2     //512
```

#### 赋值运算符

赋值运算符用于给变量赋值，除了常见的等号赋值运算符(`=`)之外，还有如下十一个复合赋值运算符：

* `x += y`：等价于`x = x + y`
* `x -= y`：等价于`x = x - y`
* `x *= y`：等价于`x = x * y`
* `x /= y`：等价于`x = x / y`
* `x %= y`：等价于`x = x % y`
* `x >>= y`：等价于`x = x >> y`
* `x <<= y`：等价于`x = x << y`
* `x >>>= y`：等价于`x = x >>> y`
* `x &= y`：等价于`x = x & y`
* `x |= y`：等价于`x = x | y`
* `x ^= y`：等价于`x = x ^ y`

注意：`a op= b`和`a = a op b`在多数情况下相等。但是如果a中包含具有副作用的表达式，两者就会有一定区别。

```javascript
var arr1 = [1,2,3,4,5],arr2 = [1,2,3,4,5];
var i = 1,k = 1;
arr1[i++] *= 2;
arr1[1];		//4
arr2[k++] = arr2[k++]*2;
arr2[1];		//6
/*
a op= b的形式，a计算一次;a  = a op b的形式，a计算两次
所以：i++表达式的值是1
因此：arr1[1] = arr1[1] * 2 = 2*2 = 4;
而第二种形式a要计算两次
因此：arr2[k++] = arr2[k++] * 2
	 arr2[1] = arr2[2] * 2 = 3 * 2 =6
*/
```

#### 比较运算符

比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件。JavaScript一共有如下八个比较运算符：

* 相等运算符(`==`)
* 严格相等运算符(`===`)
* 不相等运算符(`!=`)
* 严格不相等运算符(`!==`)
* 小于运算符(`<`)
* 小于或等于运算符(`<=`)
* 大于运算符(`>`)
* 大于或等于运算符(`>=`)

比较运算符可以比较各种类型的值，而不仅仅是数值。其中，相等运算符和严格相等运算符有自身的比较规则，其余六个比较运算符的比较规则如下：

* 如果两个运算子都是字符串，则按照Unicode码点顺序比较
* 否则，将两个运算子都转成数值(先调用`Number()`)，再进行比较

##### 字符串的比较

JavaScript引擎内部首先比较字符串首字符的Unicode码点，如果相等，再比较第二个字符的Unicode码点，以此类推。

```javascript
'cat' > 'dog' // false
'cat' > 'catalog' // false
```

当然JavaScript还提供了`String.prototype.localeCompare()`方法来比较两个字符串。该方法返回一个整数，如果该整数小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，则表示第一个字符串大于第二个字符串。

```javascript
"A".localeCompare("a");		//1，不一定是1，取决于JavaScript的实现
"A".localeCompare("B");		//-1
"A".localeCompare("A");		//0
```

此外，该方法最大的特点就是会考虑自然语言的排序。例如：正常情况下，大写英文字母小于小写英文字母。但是使用比较运算符进行比较时，JavaScript采用的是Unicode码点比较。

```javascript
'B'.localeCompare('a')  // 1
'B' > 'a' 				// false
```

注意：比较运算符的操作数偏爱数字类型，只有当操作数都是字符串时才会进行字符串比较操作。另外`>=`和`<=`在判断相等时，采用的是非严格等于。并且其中一个操作数是NaN时，四个比较运算符都会返回false。

##### 非字符串的比较

* 如果是两个原始类型值的比较，除了相等运算符和严格相等运算符，其它比较运算符都是先转成数值后再比较。但是有一特殊情况，即任何值和NaN比较，返回的都是false。

  ```javascript
  5 > '4' 		// true 等价于5 > Number('4')
  NaN > NaN		//false
  ```


* 如果运算子是对象，那么会先转为原始类型值后再进行比较。具体转换规则是：会先调用该对象上`valueOf()`方法，如果返回的还是对象本身，再接着调用对象上的`toString()`方法。

  ```javascript
  [2]	> '11'			//true
  [2] > [1] 			// true
  ```

##### 严格相等运算符

严格相等运算符的比较规则如下：

* 如果两个值类型不同，直接返回false

* 如果两个值类型相同且是基本数据类型，值相同就返回true，值不同就返回false

* 如果两个值类型是引用数据类型，引用同一个内存地址就返回true，否则就返回false

* 如果两个值是undefined或null，那么它们与自身相等，而互相不等

  ```javascript
  undefined === undefined		//true
  null === null				//true
  null === undefined			//false
  ```

严格相等运算符有一个对应的运算符是非严格相等运算符，两者的运算结果正好相反。

##### 相等运算符

相等运算符在比较相同类型的值时，与严格相等运算符完全一样。而当比较不同类型的值时，相等运算符会先将该值进行类型转换，然后再用严格相等运算符进行比较，具体规则如下：

* 如果运算子都是原始类型值，那么先转换成数值类型后，再进行比较

* 如果运算子一个是引用类型值，另一个是基本数据类型，那么先转换成原始类型后，再进行比较

  ```js
  // 对象与数值比较时，对象转为数值
  [1] == 1 // true
  // 等同于 Number([1]) == 1
  
  // 对象与字符串比较时，对象转为字符串
  [1] == '1' // true
  // 等同于 String([1]) == '1'
  [1, 2] == '1,2' // true
  // 等同于 String([1, 2]) == '1,2'
  
  // 对象与布尔值比较时，两边都转为数值
  [1] == true // true
  // 等同于 Number([1]) == Number(true)
  [2] == true // false
  // 等同于 Number([2]) == Number(true)
  ```

* 如果运算子是undefined或null，那么它们与自身不等，而互相相等

  ```javascript
  null == null				//false
  undefined == undefined		//false
  null == undefined			//true
  ```

相等运算符有一个对应的运算符是非相等运算符，两者的运算结果正好相反。

#### 布尔运算符

布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

- 取反运算符：`!`
- 且运算符：`&&`
- 或运算符：`||`
- 三元运算符：`?:`

##### 取反运算符

取反运算符(`!`)用于将布尔值变为其相反值，而对于非布尔值的数据，取反运算符会自动将其转为布尔值，具体转换规则是：其中undefined，null，false，0，NaN和空字符串取反后为true，其余值取反后都为false。

如果对一个值连续两次取反运算，就相当于将其转换为对应的布尔值，与`Boolean()`函数的作用相同。

##### 且运算符

且运算符(`&&`)的运算规则是：如果第一个运算子的布尔值是true，则返回第二个运算子的值(不是其对应的布尔值)。如果第一个运算子的布尔值是false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

这种跳过第二个运算子的机制，称为短路，因此该运算符可以用它取代if结构，但是不建议这样使用，因为可读性较差。注意：`&&`运算符的优先级要高于`||`运算符。

另外，且运算符可以连用，此时返回第一个布尔值为false的表达式的值。

```javascript
true && 'foo' && '' && 4 && 'foo' && true			// ''
```

##### 或运算符

或运算符(`||`)的运算规则是：如果第一个运算子的布尔值是true，则返回第一个运算子的值，且不再对第二个运算子求值。如果第一个运算子的布尔值为false，则返回第二个运算子的值。

另外，或运算符也可以连用，此时返回第一个布尔值为true的表达式的值。

```
false || 0 || '' || 4 || 'foo' || true		// 4
```

或运算符常用于为一个变量设置默认值。

```javascript
function saveText(text) {
  text = text || '';
  // ...
}
```

##### 三元条件运算符

三元条件运算符用问号和冒号分隔三个表达式，如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。

一般来说，三元条件表达式与`if...else`语句具有同样表达效果，但是两者之间有一个重要差别就是：前者是表达式，具有返回值。而后者是语句，没有返回值。所以，在需要返回值的场合，只能使用前者，而不能使用后者。

#### 位运算符

二进制位运算符用于直接对二进制位进行计算，一共有7个。

* **二进制或运算符**（or）：符号为`|`，表示若两个二进制位都为`0`，则结果为`0`，否则为`1`。
* **二进制与运算符**（and）：符号为`&`，表示若两个二进制位都为1，则结果为1，否则为0。
* **二进制否运算符**（not）：符号为`~`，表示对一个二进制位取反。
* **异或运算符**（xor）：符号为`^`，表示若两个二进制位不相同，则结果为1，否则为0。
* **左移运算符**（left shift）：符号为`<<`，详见下文解释。
* **右移运算符**（right shift）：符号为`>>`，详见下文解释。
* **带符号位的右移运算符**（zero filled right shift）：符号为`>>>`，详见下文解释。

这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点就是可读性不好。

注意：位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在JavaScript内部，数值都是以64位浮点数的形式存储，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。

```js
i = i | 0;
```

这行代码的意思就是将`i`，无论它是整数或小数，转换为32位整数。

> 在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当做0来处理。如果对非数值应用位操作符，会先使用Number()函数将值转换为数值类型，然后再进行位操作。

##### 或运算符

二进制或运算符（`|`）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。

```js
0 | 3 			//3
```

其中0和3的二进制分别是00和11，所以进行或运算符会得到11，即返回3。

位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行或运算，等同于对该数去除小数部分，即取整数位。

```js
2.9 | 0		//2
-2.9 | 0	//-2
```

需要注意的是，这种取整方法不适用超过32位整数最大值，即2147483647（等比数列可以求出）。

```js
2147483649.4 | 0;
// -2147483647
```

##### 与运算符

二进制与运算符（`&`）逐位比较两个运算子，两个二进制位之中只要有一个为0，就返回0，否则返回1。

```js
0 & 3			//0
```

##### 否运算符

二进制否运算符将每个二进制位都变为相反值。

```js
~3			//-4
```

前面说道，JavaScript在进行位运算时，会将内部所有的运算子都转为32位的二进制整数再进行运算。而3的32位整数形式是`00000000000000000000000000000011`，二进制否运算以后得到`11111111111111111111111111111100`。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript内部采用补码形式表示负数，即需要将这个数减去1，再去一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于`11111111111111111111111111111011`，再去一次反得到`00000000000000000000000000000100`，再加上负号就是`-4`。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加等于-1。

```js
~ -3		//2
```

对一个整数连续两次二进制否运算，得到它自身。但是由于所有的位运算符都只对整数有效，所以在遇到小数时，会自动将小数部分舍弃，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果。

```js
~~2.9 // 2
~~47.11 // 47
~~1.9999 // 1
~~3 // 3
```

使用二进制否进行取整，是所有取整方法中最快的一种。

对字符串进行二进制否运算，JavaScript引擎会先调用Number函数，将字符串转为数值。

```js
// 相当于~Number('011')
~'011'  // -12

// 相当于~Number('42 cats')
~'42 cats' // -1

// 相当于~Number('0xcafebabe')
~'0xcafebabe' // 889275713

// 相当于~Number('deadbeef')
~'deadbeef' // -1
```

> 其中Number函数转换规则参照前面知识。

对于其他类型的值，二进制否运算也是先用Number转换为数值，然后再进行处理。

```js
// 相当于 ~Number([])
~[] // -1

// 相当于 ~Number(NaN)
~NaN // -1

// 相当于 ~Number(null)
~null // -1
```

##### 异或运算符

异或运算`^`在两个二进制位不同时，返回1，相同时返回0。

```js
0 ^ 3 // 3
```

上面表达式中，`0`（二进制`00`）与`3`（二进制`11`）进行异或运算，它们每一个二进制位都不同，所以得到`11`（即`3`）。

异或运算有一个特殊作用，连续对两个数`a`和`b`进行三次异或运算可以互换它们的值。这意味着，使用异或运算可以在不引人临时变量的前提下，互换两个变量的值。

```js
var a = 1
var b = 2

a ^= b, b ^= a, a ^= b;

a // 2
b // 1
```

> 这是互换两个变量的值的最快方法。

异或运算也可以用来取整。

```js
12.9 ^ 0 // 12
```

上面代码中，`-4`左移一位得到`-8`，是因为`-4`的二进制形式是`11111111111111111111111111111100`，左移一位后得到`11111111111111111111111111111000`，该数转为十进制（减去1后取反，再加上负号）即为`-8`。

##### 左移运算符

左移运算符（`<<`）表示将一个数的二进制值向左移动指定的位数，尾部补上0，即乘以2的指定次方。

```js
// 4 的二进制形式为100，
// 左移一位为1000（即十进制的8）
// 相当于乘以2的1次方
4 << 1
// 8

-4 << 1
// -8
```

如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。

```js
13.5 << 0
// 13

-13.5 << 0
// -13
```

左移运算符用于二进制数值非常方便。

```js
var color = {r: 186, g: 218, b: 85};

// RGB to HEX
// (1 << 24)的作用为保证结果是6位数
var rgb2hex = function(r, g, b) {
  return '#' + ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16) // 先转成十六进制，然后返回字符串
    .substr(1);   // 去除字符串的最高位，返回后面六个字符串
}

rgb2hex(color.r, color.g, color.b)
// "#bada55"
```

上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值。

##### 右移运算符

右移运算符（`>>`）表示将一个数的二进制值向右移动指定的位数，头部补`0`，即除以`2`的指定次方（最高位即符号位不参与移动）。

```js
4 >> 1
// 2
/*
// 因为4的二进制形式为 00000000000000000000000000000100，
// 右移一位得到 00000000000000000000000000000010，
// 即为十进制的2
*/

-4 >> 1
// -2
/*
// 因为-4的二进制形式为 11111111111111111111111111111100，
// 右移一位，头部补1，得到 11111111111111111111111111111110,
// 即为十进制的-2
*/
```

右移运算可以模拟 2 的整除运算。

```js
5 >> 1
// 2
// 相当于 5 / 2 = 2

21 >> 2
// 5
// 相当于 21 / 4 = 5

21 >> 3
// 2
// 相当于 21 / 8 = 2

21 >> 4
// 1
// 相当于 21 / 16 = 1
```

##### 带符号位的右移运算符

带符号位的右移运算符（`>>>`）表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补`0`。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（`>>`）完全一致，区别主要在于负数。

```
4 >>> 1
// 2

-4 >>> 1
// 2147483646
/*
// 因为-4的二进制形式为11111111111111111111111111111100，
// 带符号位的右移一位，得到01111111111111111111111111111110，
// 即为十进制的2147483646。
*/
```

这个运算实际上将一个值转为32位无符号整数。

查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。

```js
-1 >>> 0 // 4294967295
```

上面代码表示，`-1`作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即`(2^32)-1`，等于`11111111111111111111111111111111`）。

#### 其他运算符

##### void运算符

void运算符的作用是执行一个表达式，然后返回undefined。

```javascript
void 0			//undefined
void(0)			//undefined
void 1 + 2		//NaN，void运算符优先级很高，可能会造成歧义
void(1 + 2)		//undefined，为了防止歧义，建议总是加上括号。
```

void运算符主要用于在链接中插入代码，防止浏览器的默认行为。

```html
<a href="#" onclick="f();return false">click</a>
<script>
  function f(){
  }
</script>
<!--上述代码合成一段代码-->
<a href="javascript: void(f())">click</a>
```

之所以会设计`void`运算符，主要是因为`undefined`不是`JavaScript`的保留字。

```js
(function() {
    const undefined = 1				// 覆盖全局undefined
    console.log(undefined)			// 1
})()
```

这样便于你直接通过`void`运算符快速产生`undefined`。

##### 逗号运算符

逗号运算符用于对两个表达式求值，并返回最后一个表达式的值。

```js
'a', 'b' // "b"

var x = 0;
var y = (x++, 10);
x // 1
y // 10
```

逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。

```js
var value = (console.log('Hi!'), true);
// Hi!

value // true
```

##### in运算符

in运算符用于检查对象中是否包含某个属性，如果包含就返回true，否则就返回false。在JavaScript中，所有全局变量都是顶层对象(浏览器的顶层对象是window对象)的属性，因此通过in运算符可以判断一个全局变量是否存在。

```javascript
if(a){}					//如果a不存在，报错
if(window.a){}			//如果a是假值，无法得到正确结果
if('a' in window){}		//正确
```

另外，in运算符会进行原型链查找，也就是说继承而来的属性同样会返回true。

```javascript
var arr = [1,2]			//in运算符也可以作用于数组
"0" in arr   			//true
1 in arr	   			//true
2 in arr	   			//false
"toString" in arr		
//true，必须加引号，否则视为变量处理。如果是数字键，则不需要，因为会自动转换为字符串
```

##### typeof运算符

typeof运算符常常用来进行基本数据类型判断。该运算符可以加上括号，让其看起来更像是全局函数，其运算结果如下表：

| x          | typeof x                                 |
| ---------- | ---------------------------------------- |
| undefined  | "undefined"                              |
| null       | "object"                                 |
| true/false | "boolean"                                |
| 数字或NaN     | "number"                                 |
| 字符串        | "string"                                 |
| 函数         | "function"                               |
| 内置对象(非函数)  | "object"                                 |
| 数组         | "object"                                 |
| 自定义对象      | "object"                                 |
| 宿主对象       | 大多数返回"object"，也可能返回由编译器实现的字符串，但不可能是"undefined"、"boolean"、"number"和"string" |

前面了解到使用未经声明的变量会报错，但是配合typeof运算符使用可以避免这种情况。

```javascript
if(typeof v === "undefined") {
  console.log("v变量没有进行声明，但是不会报错");
}
```

> 未声明的变量调用delete也不会报错，但是这样并没有实际意义，并且在严格模式下确实会导致错误。
>

##### delete运算符

delete运算符用来删除对象属性或者数组元素。该操作符期望操作数是左值，如果不是，将不会做任何操作并返回true。否则就会尝试删除，删除成功就会返回true。但是并不是所有的左值都能删除，一些内置对象和宿主对象属性是不能删除的，还有显式用var声明的变量以及function语句定义的函数和函数参数也是不能删除的。

还有当删除数组元素时，并不是真正的删除数组元素，只是将被删除元素的索引设置为undefined。因此数组长度并不会有所改变。

```javascript
var o = {x:1};
delete o.x;
"x" in o; 		//false
var arr = [1,2,3];
delete arr[2];
2 in arr; 		//false
arr.length; 	//3
arr[2];			//undefined
```

在ES5中，如果delete操作数是非法的，像以1x开头的命名非法，会抛出SyntaxError。并且在严格模式下，删除不可配置属性会抛出TypeError。但是在非严格模式下，仅仅返回false，但是不会报错。

注意：eval()函数中定义的变量是可以删除的，使用删除后的变量抛出ReferenceError

```javascript
eval("var a = 1");
a;			//1
delete a;	//true
a;			//ReferenceError
```

#### 运算顺序

##### 优先级

JavaScript中运算符的优先级是不同的，优先级高的运算符先执行，优先级低的运算符后执行。因此，为了防止歧义，常常使用圆括号来提高运算的优先级，因为括号的优先级是最高的。

但是括号并不是一种运算符，所以不具有求值作用，而是一种语法结构。它有两种用法：

* 一种是把表达式放在圆括号之中，提升运算的优先级
* 一种是跟在函数的后面，作用是调用函数。

```javascript
var x = 1;
(x) = 2;			//如果具有求值作用，那么就是1=2，会报错
```

另外，圆括号之中只能放置表达式，如果将语句放在圆括号之中，就会报错。

```javascript
(var a = 1)		// SyntaxError: Unexpected token var
```

如果将函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。

```js
function fn(){
    console.log(1)
}

(fn)			//function fn(){console.log(1)}
```

##### 结合性

运算符有结合性，它规定了优先级相同情况下的运算顺序。如果运算符具有左结合性，即表示运算顺序是从左到右。如果具有右结合性，即表示从右边开始计算。

```javascript
var r1 = a + b + c				//左结合
//var r1 = ((a + b) + c)
var r2 = w = e = r				//右结合
//var r2 = (w = (e = r))		
var r3 = a?b:c?d:e?f:g			//右结合
//var r3 = (a?:b(c?d:(e?f:g)))
```

### 数据类型转换

#### 概述

JavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。

```js
var x = y ? 1 : true
```

变量x的数据类型取决于变量y，这意味着x的类型没法在编译阶段知道，必须等到运行时才能知道。

虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。

#### toString()和valueOf()

在了解具体的转换规则之前，需要先了解toString()和valueOf()这个两个方法。一般来说，所有的对象都继承了Object.prototype上的toString()方法，该方法只是简单返回反映对象类型的字符串。注意：可以进行类型检测。

```javascript
Object.prototype.toString().call(1);	//"[object Number]"
```

但是许多类都不满足仅仅返回反映该对象的字符串，因此又重写了该方法。例如：

- Number.prototype上的toString()方法不仅仅将数字转换为字符串，而支持进制转换。


- Array.prototype上的toString()方法将每个数组元素转换其字符串形式，并在元素之间添加逗号后合并成结果字符串。当然每个数组元素又有其自身的转换方法
- Function.prototype上的toString()方法返回这个函数的字符串形式
- Date.prototype上的toString()方法返回该日期的字符串形式
- RegExp.prototype上的toString()方法返回该正则表达式的字符串形式

而对于valueOf()来说也是如此，继承自Object.prototype上的valueOf()方法用来将对象转换为对应的基本类型，但是如果无法转换为原始值，该方法就会简单返回该对象本身。注意：valueOf()方法不像toString()方法被很多类重写，而只有Date类重写了该方法，用来返回距离1970年1月1日的毫秒数。

注意：基于这两个方法的转换规则只适用于本地对象，而宿主对象会根据各自的实现转换为其对应的基本类型。

#### 强制转换

##### Number()

使用`Number()`函数可以将任意类型值转换成数值，转换规则如下：

* 如果参数是除字符串之外的原始类型值

  ```javascript
  Number(1);			//1
  Number(true);		//1
  Number(false);		//0
  Number(null);		//0
  Number(undefined);	//NaN
  ```

* 如果参数是字符串

  * 如果字符串只包含数字（包括前面带正好或负号的情况），则将其转换为十进制数值

    ```js
    Number("1")					//1
    Number("011")				//11，前导0会被忽略
    ```

  * 如果字符串中包含有效的浮点格式，则将其转换为对应的浮点数值。注意：同样会忽略前导0

    ```js
    Number("1.1")				//1.1
    ```

  * 如果字符串中包含有效的十六进制格式，则将其转换为对应的十六进制整数值

    ```js
    Number("0xee")				//238
    ```

  * 如果是空字符串，那么会转换为数值0

  * 如果字符串中包含除上述格式之外的字符，则将其转换为NaN

  ```js
  Number("1a");		//NaN
  parseInt("1a");		//1
  parseInt("");		//NaN
  Number("");			//0
  ```

  其中，将字符串转换为数值类型要比使用`ParseInt()`方法要严格许多，只要字符串中有一个字符无法转换成数值，就直接返回NaN。并且在转换过程中，同样会自动过滤一个字符串前导和后缀的空白字符

* 如果参数是引用类型值时，具体转换规则如下：

  * 调用对象自身的`valueOf`方法，如果返回原始类型的值，则直接对该值使用`Number()`函数，转换步骤参照前面基本类型转换为数值类型，不再进行后续步骤
  * 如果`valueOf()`方法返回的结果是对象本身，则改为调用对象自身的`toString()`方法。如果`toString()`方法返回原始类型值，则对该值使用`Number()`函数，参照字符串转换为数字规则，不再进行后续步骤
  * 如果`toString()`方法返回的是对象，就会返回报错。 

  ```javascript
  Number({a: 1}) 		// NaN
  Number([1, 2, 3]) 	// NaN
  Number([5]) 		// 5
  ```

  默认情况下，对象的`valueOf()`方法返回对象本身，而`toString()`方法返回的是标识该对象的类型字符串。 

  ```javascript
  var obj = {x: 1};
  Number(obj) // NaN
  //等同于
  obj.valueOf();				//{x:1}
  obj.toString();				//[object Object]
  Number('[object Object]');	//NaN
  //例子
  var o = {}
  o.valueOf = function(){
      return [10];
  }
  console.log(0 + 1);			
  //"[object Object]1"，说明不是在valueOf()的基础上再接着调用toString()
  ```

##### String()

使用`String()`函数，可以将任意类型值转换成字符串，转换规则如下：

* 如果参数是原始类型值时，转换规则如下：
  * 数值：转为对应的字符串形式
  * 字符串：保持不变
  * 布尔值：转为对应的字符串形式
  * undefined：转为对应的字符串形式
  * null：转为对应的字符串形式

  ```javascript
  String(123) 		// "123"
  String('abc') 		// "abc"
  String(true) 		// "true"
  String(undefined) 	// "undefined"
  String(null) 		// "null"
  ```
* 如果参数是引用类型值时，转换规则如下：
  * 先调用对象自身的`toString()`方法，如果返回原始类型值，则对该值使用`String()`函数，不再进行以下步骤
  * 如果`toString()`方法返回的是对象，再调用原对象的`valueOf()`方法。如果`valueOf()`方法返回原始类型的值，则对该值使用`String()`函数，不再进行一下步骤
  * 如果`valueOf()`方法返回的是对象，就报错。 

  ```javascript
  String({x:1});				//"[object Object]"
  String([1,2]);				//"1,2"
  function fn(){}
  String(fn);		//"function fn(){}"
  //等价于
  String(fn.toString());	//继承自Function.prototype.toString()
  ```

简单来说就是如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果。如果值是null或undefined，则返回`null`或`undefined`。

##### Boolean()

使用`Boolean()`函数，可以将任意类型值转换为布尔值。转换规则如下：

* undefined，null，0(+0或-0)，NaN和空字符串都转换为false
* 其余值转换为true

所有对象的布尔值都是true，这是因为JavaScript设计之初出于性能的考虑。如果对象需要计算才能得到布尔值，那么对于`obj1&&obj2`这样的场景，可能需要大量的计算。因此为了保证性能，就同一规定，对象的布尔值为true。

```javascript
Boolean(false);				//false
Boolean([]);				//true
Boolean(new Boolean(false));//true，所有对象转换为布尔值都是true
```

##### Object()

使用`Object`函数，可以将任意类型值转换为对象类型。它的转换规则也相对简单，基本数据类型转换为其对应的包装对象，其中null和undefiend会被忽略，直接返回空对象。而如果是引用类型，那么就直接返回其本身。

```javascript
Object()			//{}
Object(null);		//{}
Object(undefined);	//{}
Object(1);			//Number {[[PrimitiveValue]]: 1}
Object(true);		//Boolean {[[PrimitiveValue]]: true}
Object("hi");		//String {[[PrimitiveValue]]: "hi"}
Object([]);			//[]
Object({});			//{}
Object(function fn(){});	//function fn(){}
```

#### 自动转换

自动类型转换是以强制类型转换为基础的，它的规则可以理解为：预期什么类型值，就调用该类型的转换函数。但是由于自动转换具有不确定性，不易排错，因此建议在预期为布尔值、数值、字符串的地方，全部使用`Boolean`、`Number`和`String`函数进行显式转换。

##### 自动转换为布尔值

当 JavaScript 遇到预期为布尔值的地方(比如`if`语句的条件部分)，就会将非布尔值的参数自动转换为布尔值。转换规则和显式调用`Boolean`函数转换一样。

此外，下面两种写法也可以将一个表达式转换为布尔值，它们内部也是调用`Boolean`函数进行转换。

```javascript
expression ? true : false
!! expression
```

##### 自动转换为字符串

JavaScript 遇到预期为字符串的地方，就会将非字符串的数据自动转为字符串。具体规则和显式调用`String`函数转换一样。

此外，字符串的自动转换主要发生在当`+`运算符的操作数一个字符串，另一个是非字符串时，JavaScript会自动将非字符串转换为字符串。

```
'5' + 1 			// '51'
'5' + true 			// "5true"
'5' + {} 			// "5[object Object]"
'5' + [] 			// "5"	[].toString()=>""
'5' + function (){} // "5function (){}"
'5' + undefined 	// "5undefined"
'5' + null 			// "5null"
```

##### 自动转换为数值

当JavaScript遇到预期为数值的地方，就会将参数值自动转换为数值。具体转换规则和显式调用`Number`函数转换一样。

注意：除了`+`运算符偏爱字符串类型，其它算术运算符都偏爱数值类型。

```
'5' - '2' 		// 3
'5' * '2' 		// 10
true - 1  		// 0
'5' * []    	// 0，[].valueOf()=>[]，[].toString()=>""，Number("")=>0
'1'*1			// 1
```

此外，一元运算符也可以将参数值转换数值类型。

```javascript
+'abc'	 	// NaN
-'abc' 		// NaN
+true 		// 1
-false 		// 0
```

#### 数字和字符串相互转换

一般来说，数字和字符串之间的转换最常见。如果是数字转换为字符串，那么就会先将数字转换为对应的包装对象，然后再调用Number.prototype.toString()进行转换(重写后支持进制)。

toString()方法接受一个可选参数，表示输出的进制。如果省略该参数，默认将数值先转换为十进制，再输出其对应字符串形式。否则，就根据参数指定的进制，将一个数字转换为某个进制的字符串。注意：将其它进制的数转回十进制，需要使用parseInt()方法。

```javascript
var num = 10;
num.toString();		//"10"
num.toString(10);	//"10" 
num.toString(8);	//"12"
num["toString](16);	//"a"
10["toString"](2);	//"1010"
//例子
(10).toString();	//"10"，必须加上括号，否则引擎会将点解析成小数点，从而抛出SyntaxError。
10..toString();			
10 .toString();
10.0.toString();
//或者改进为上面三种方式，这样引擎会将第一个点解析成小数点，第二个点自然就被解析成点运算符
//所以这也说明可以直接在小数上直接调用该方法
10.5.toString() 	// "10.5"
10.5.toString(2) 	// "1010.1"
10.5.toString(8) 	// "12.4"
10.5.toString(16) 	// "a.8"
```

不仅如此，Number.prototype上还额外定义了三个方法用来将数字转换为指定的字符串。

- toFixed()，该方法接收一个参数，用来指定小数点后的位数，然后返回其对应的字符串形式。注意：该方法会进行四舍五入，并且参数(小数)的范围是0~20，超出这个范围将抛出RangeError。
- toExponential()，该方法用来将一个数转换为其对应的科学计数法的字符串形式，它接受一个参数用来指定小数点后有效数字的位数，范围是0~20，超出这个范围将抛出RangeError。
- toPrecision()，该方法接受一个参数，用来指定有效数字的位数，然后返回其对应的字符串形式。若有效数字的位数小于数字整数部分，就会转换为指数形式。注意：该方法会进行四舍五入，并且参数的范围是1~21，超出这个范围将抛出RangeError。此外，该方法用于四舍五入时不太可靠，原因是浮点数不能精确存储。

```javascript
var n = 123.456;
n.toFixed(0);	 		//"123"
n.toFixed(1);			//"123.5"
n.toFixed(4);	 		//"123.4560"
n.toFixed(null); 		//"123",如果参数不是数字,则忽略该参数，按照参数是0处理
n.toExponential(0);		//"1e+2"
n.toExponential(3);		//"1.235e+2"
n.toExponential(6);		//"1.234560e+2"
n.toExponential(null);	//"1e+2",参数不是数字，则忽略该参数，按照参数是0处理
n.toPrecision(3);		//"123"
n.toPrecision(2);		//"1.2e+2"
n.toPrecision(4);		//"123.5"
n.toPrecision(7);		//"123.4560"
n.toPrecision(null);	//报错，参数必须是数字
```

而如果是字符串转换为数字，除了使用`Number`函数之外(详细看上面)，还可以使用`parseInt`和`parseFloat`这两个全局函数。

其中，parseInt()方法可以将字符串或小数转换为整数，并且如果字符串头部有空白符，会自动忽略。

```javascript
parseInt(1.2);		//1
parseInt("	2");	//2
```

将字符串转换为整数的时候，是一个个字符依次转换，如果遇到不能转换为数字的字符，就不再进行下去，返回已经转好的部分。但是如果遇到第一个字符就不能转换为数字(正负号除外)，则返回NaN。

```javascript
parseInt("8a");		//8
parseInt("a1a");	//NaN
parseInt(".1");		//NaN
parseInt("");		//NaN
```

parseInt()方法还接收第二个参数(2到36之间)，表示被解析的值的进制。如果第二个参数不是数值，会被自动转换为整数。并且如果这个整数不是2~36之间，就返回NaN。如果第二个参数是`0`，`undefined`和 `null`就直接忽略。

```javascript
parseInt(1000,2);		//8，二进制的1000转换十进制的8
parseInt(1000, 6) 		// 216
parseInt(1000, 8) 		// 512	
parseInt(10,null);		//10
parseInt(10,100);		//NaN
```

注意：如果第一个参数是数值的话，会先将这个数值转换为十进制，然后再应用第二个参数。而如果第一个参数是字符串，则会直接用指定进制解读这个字符串。

```javascript
parseInt(0x11, 36) 		// 43，0x11转换为十进制为17
parseInt(17, 36) 		// 43
parseInt('0x11', 36) 	// 42805，33*36^2+36+1 = 42805，也就是说三十六进制的0x11转换为十进制为42805
parseInt('x', 36) 		// 33
parseInt(010, 2) 		// NaN，八进制010转换为十进制为8，而二进制8不存在，也就是二进制最大就1，所以返回NaN
```

此外，如果第一个参数是字符串，且以`0x`或`0X`开头，而第二个参数省略或为0，则parseInt()会自动将第二个参数设为16。

```javascript
parseInt('0xFF') // 255
parseInt('0xFF', 0) // 255
parseInt('0xFF', 16) // 255
parseInt('0xFF', 10) // 0
```

parseInt()方法的很多复杂行为都是由于八进制的前缀0引发的，因此ES5不再将传入带有前缀0的数字，视为八进制数，而是要求忽略这个零。但是为了兼容性，大部分浏览器还未实现该标准。注意：ES5严格模式下禁止使用八进制数字，所以不建议使用八进制数字。

```javascript
parseInt(010, 8) // NaN，行为怪异
parseInt(10, 8) // 8
parseInt('010', 8) // 8
```

另外，对于那些会自动转为科学计数法的数字，parseInt()方法会将科学计数法的表示方法视为字符串，因此可能会导致意料之外的结果。

```javascript
parseInt(1000000000000000000000.5, 10) // 1
// 等同于
parseInt('1e+21', 10) // 1

parseInt(0.0000008, 10) // 8
// 等同于
parseInt('8e-7', 10) // 8
```

对于类似的parseFloat()方法用来将字符串转换为浮点数，如果字符串包含不能转换为浮点数的字符，则不再进行转换，返回已经转好的部分。并且parseFloat()方法和parseInt()一样，都会自动过来字符串前的空白字符，以及遇到第一个字符不能转换为浮点数，就直接返回NaN。

```javascript
parseFloat("3.14");
parseFloat("314e-2");
parseFloat("0.0314E+2");
parseFloat("3.14more");			//都是3.14
parseFloat("\t\v\r12.34\n ")	// 12.34
parseFloat("FF2") 				// NaN
parseFloat("") 					// NaN
```

此外，parseInt()，parseFloat()两个方法与Number()方法转换结果不同。

```javascript
parseFloat(true)  	// NaN
Number(true) 		// 1
parseFloat(null) 	// NaN
Number(null) 		// 0
parseFloat('') 		// NaN
Number('') 			// 0
parseFloat('1.45#') // 1.45
Number('1.45#') 	// NaN
```

### 错误处理机制

#### Error对象

代码解析或执行时，一旦发生错误，JavaScript引擎就会抛出一个错误对象，这个错误对象是JavaScript原生提供`Error()`构造函数的实例。

这个构造函数接受一个参数，表示错误提示，可以从实例的`message`属性获取这个参数。

```javascript
var err = new Error('出错了');//手动生成一个错误对象实例
err.message 				// "出错了"
```

代码解析或运行时发生错误，JavaScript引擎就会自动产生、并抛出一个`Error`对象的实例，然后整个程序就中断在发生错误的地方，不再往下执行。

根据语言标准，`Error`对象的实例必须有`message`属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。

- **message**：错误提示信息
- **name**：错误名称（非标准属性）
- **stack**：错误的堆栈（非标准属性）

利用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。

#### 自定义错误

除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。

```javascript
function UserError(message) {
   this.message = message || "默认信息";
   this.name = "UserError";
}

UserError.prototype = new Error();
UserError.prototype.constructor = UserError;
```

上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义的错误了。

```javascript
new UserError("这是自定义的错误！");
```

#### throw语句

除了JavaScript引擎自动抛出异常之外，还可以使用throw语句手动抛出异常。其中expression可以是任意类型，例如一个代表错误码的数字或者代表错误信息的字符串。

```javascript
throw expression
```

但是无论是哪种异常，JavaScript都会立即停止后面语句的执行，并且寻找最近的异常处理程序，如果一直没找到就会将这个异常汇报给用户。

```javascript
try{
    throw "error"
  	console.log("hello")	//停止执行
}catch(e){
    console.log(e)
}
console.log("hi")			//正常执行
//"error" "hi"
```

此外，如果throw语句在函数中，那么该函数调用会被放弃，并且控制流跳转到调用该函数的的try语句的catch语句中。

```javascript
function fn(){
    throw new Error("发生错误");
  	console.log(123);
}
try{
    fn();
}catch(e){
    console.log(e.message);
}
```

#### try...catch...finally语句

try/catch/finally语句是JavaScript中的异常处理机制。其中try从句中定义异常所在的代码块，catch从句中定义了异常处理逻辑。尽管catch语句和finally语句是可选的，但是try语句至少跟上它们二者之一才能组成完整的语句。并且即使是一条语句大括号也是不能省略的。

```javascript
try {
  //js解释器抛出异常，或者使用throw手动抛出异常
}
catch(e) {
  //只有try语句中抛出异常，catch语句才会执行
  //参数e来获得对Error对象或者抛出的其他值的引用，注意这里的e具有块级作用域，只在catch语句中有效
  //可以处理该异常，也可以忽略该异常
  //也可以通过throw语句重新抛出异常
}
funally {
  //无论是否抛出异常，finally语句总是会被执行
}
//例子
function fn(){
    try{
        console.log("hello")
      	return "world";
    }finally{
        console.log("hi")
    }
}
fn();	//"hello" "hi"，结果表明finally语句总是会执行
```

如果try语句中发生了异常，那么JavaScript解释器会寻找与之相关的catch语句来处理异常，最后再执行finally语句。但是如果不存在处理异常的catch语句，就会先执行finally语句，然后向上传播这个异常，直至找到处理这个异常的catch从句。

```javascript
try {
  try{
    throw new Error("oops");
  }catch(e) {
    console.error("inner",e.message);
    throw ex;
  }finally {
    console.log("finally");
  }
}catch(e){
  console.error("outer",e.message);
}
/* 输出
	inner oops
	finally
	outer oops
*/
//例子
function f() {
  try {
    console.log(0);
    throw 'bug';
  } catch(e) {
    console.log(1);
    return true; // 这句原本会延迟到finally代码块结束再执行
    console.log(2); // 不会运行
  } finally {
    console.log(3);
    return false; // 这句会覆盖掉前面那句return
    console.log(4); // 不会运行
  }

  console.log(5); // 不会运行
}

var result = f();
// 0
// 1
// 3

result
// false
```

此外，如果catch从句重新抛出异常，那么就会立即执行finally从句。

```javascript
function f() {
  try {
    throw '出错了！';
  } catch(e) {
    console.log('捕捉到内部错误');
    throw e; 		// 这句原本会等到finally结束再执行
  } finally {
    return false; 	
    /* 
    但是由于return语句就直接跳出函数体，不再执行throw e。
    如果改为console.log("hello")，输出结果就为
    	"捕捉到内部错误"
    	"hello"
    	"caught outer \"bogus\""
  	*/
  }
}
try {
  f();
} catch(e) {
  // 此处不会执行
  console.log('caught outer "bogus"');
}
//捕捉到内部错误
```

#### debugger语句

debugger语句用来产生一个断点，js代码的执行会停止在断点的位置，常常用来调用js程序。debugger语句ES5中才被列入规范，但是在这之前，一些JavaScript的实现就拥有该功能。

### eval语句

类似于其它解释性语言，JavaScript预定义的全局函数`eval()`可以解释执行由JavaScript代码组成的字符串。关于eval语句有如下几点需要注意：

- `eval()`是一个函数，但是大部分人却把它看作是运算符
- JavaScript引擎在解析执行代码时，会做大量的代码分析和优化(一般编译时优化)，但是动态指定的JavaScript代码却无法被优化。因为`eval()`执行的不确定性导致运行时才执行，很大程度上拖慢运行速度，因此不推荐使用
- `eval()`可以被赋值给另一个变量，然后这个变量就会拥有同样的功能。这也是不推荐使用的一个原因。

`eval()`期望接受一个字符串参数，如果不是字符串，就会直接返回这个参数。如果是，会尝试将该字符串当做JavaScript代码编译，若编译失败则抛出SyntaxError；若编译成功则开始执行该代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或语句没有值则返回undefined。如果字符串产生异常并且字符串内没有相应的异常处理程序就会传递给用户。

```javascript
eval('var a = 1;')
a						 		// 1
eval('return;')					//报错，因为return不能单独使用，必须在函数中使用
```

`eval()`没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量值，造成安全问题。为了防止这种风险，在严格模式下，明确规定通过`eval()`内部声明的变量，不会影响到外部作用域。但是，即使在严格模式下，`eval()`依然可以读写当前作用域的变量。 

```javascript
(function f() {
  'use strict';
  eval('var foo = 123');
  console.log(foo);  		// ReferenceError
})()
(function f() {
  'use strict';
  var foo = 1;
  eval('foo = 2');
  console.log(foo);  // 2
})()						//由此可见，安全风险依旧存在
```

JavaScript引擎内部，`eval()`实际上是一个引用，默认调用一个内部方法。这使得可以分为如下两种情况使用它：

- 直接调用。这种情况下，`eval()`的作用域就是当前作用域 
- 间接调用。这种情况下，`eval()`的作用域是全局作用域

```javascript
var a = 1;
function f() {
  var a = 2;
  var e = eval;			//只要不是直接调用eval()，其它方式都是间接调用
  e('console.log(a)');
}
f() 				// 1
```

`eval()`的间接调用方式有多种，只要不是直接调用，其余方式都属于间接调用。这就导致JavaScript引擎在静态代码分析阶段，根本无法分辨执行的是eval，不利于引擎优化执行速度。

为了保证eval的别名不影响代码优化，JavaScript的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域，即便是在函数作用域内部执行。

```javascript
eval.call(null, '...')
window.eval('...')
(1, eval)('...')
(eval, eval)('...')
```

另外，`eval()`最常见的应用场景是解析JSON字符串，不过更好的做法是使用`JSON.parse()`方法。

### with语句

with语句的作用是操作同一个对象的对个属性时，提供一些书写的方便。

```javascript
with (o) {
  p1 = 1;
  p2 = 2;
}
// 等同于
o.p1 = 1;
o.p2 = 2;
```

注意：with语句内部的变量必须是当前对象中已经存在的属性，否则就会创造一个当前作用域的全局变量。这是因为with语句没有改变作用域，它的内部依然是当前作用域

```javascript
var o = {}
with(o){
    x = 1;
}
o.x			//undefined
x			//1，当前作用域下存在该变量
```

正是由于with语句绑定对象的不确定性，所以在严格模式下，禁止使用with语句。并且从代码上来看，无法直接判断x是全局变量还是o对象上的属性，这会非常不利于代码的除错和模块化，并且编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度，因此不建议使用with语句，而是考虑使用一个临时变量代替它。

```javascript
var temp = o.x
temp = 1
```

