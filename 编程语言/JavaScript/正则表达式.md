### 概述

JavaScript中的很多特性都是借鉴其它语言，其中语法借鉴Java，函数借鉴Scheme，原型借鉴Self，正则表达式借鉴Perl。

正则表达式（Regular Expression）是一种描述字符模式的对象，简单来说就是按照某种规则去匹配符合条件的字符串。

注意：JavaScript中的正则表达式是Perl中正则表达式的子集，像后顾等特性并不支持。

### 创建正则表达式

你可以通过字面量形式来创建正则表达式。

```js
let r = /\bis\b/			//\b表示单词边界，也就是说无法匹配"this"
```

当然你也可以通过构造函数来创建正则表达式。

```js
let r = new RegExp("\\bis\\b","g")		//"\"需要进行转义
```

这两种方式的区别：前者是在JavaScript引擎编译阶段生成正则表达式，而后者是在运行阶段，所以前者效率更高。

### 修饰符

修饰符（modifier）表示模式的附加规则，放在正则模式的尾部。

#### g修饰符

默认情况下，第一次匹配成功，正则对象就停止向下匹配。而g（global）修饰符表示全局匹配，加上它之后，正则对象将匹配全部符合条件的结果，主要用于替换和搜索。

```js
let regex = /b/
let str = 'abba'

regex.test(str) 	// true
regex.test(str) 	// true
regex.test(str) 	// true
//由于没有g修饰符，所以每次都会从字符串头部开始匹配。

let reg = /b/g

reg.test(str) 	// true
reg.test(str) 	// true
reg.test(str) 	// false
//由于含有g修饰符，所以每次都会从上一次匹配成功处开始向后匹配
```

#### i修饰符

默认情况下，正则对象区分字母大小写，加上i（ignorecase）修饰符表示忽忽略大小写。

```js
/a/.test('A') 		// false
/a/i.test('A') 		// true
```

#### m修饰符

默认情况下，`^`和`$`匹配字符串的开始和结尾处。m（mutiline）修饰符表示多行模式，即不会因为换行符只检索一行。加上它之后，`^`和`$`会识别换行符`\n`。

```js
let s = "hello world\n"

/world$/.test(s) 			// false
/world$/m.test(s) 			// true
```

### 实例属性

正则对象的实例属性分为两类，一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。

* RegExp.prototype.ignoreCase：表示是否设置了i修饰符
* RegExp.prototype.global：表示是否设置了g修饰符
* RegExp.prototype.multiline：表示是否设置了m修饰符

```javascript
var r = /is/g

r.ignoreCase		//false
r.global			//true
r.multiline			//false
```

> 这三个属性都是只读的。

另一类是与修饰符无关的属性，分别是：

* RegExp.prototype.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在全局匹配下才有意义。
* RegExp.prototype.source：返回正则表达式的字符串形式，不包含修饰符和`/`。该属性只读

```js
var reg = /\bis\b/gim

reg.source			//"\bis\b"
reg.lastIndex		//0
```

### 匹配规则

正则表达式是由两种基本字符类型组成：原义字符和元字符（metacharacters）。其中原义字符表示其本身意义的普通字符，而元字符是具有特殊含义的字符。当然还可以使用`\`对元字符进行转义，这样就可以使用元字符的原义了。并且也可以使用`\`对原义字符进行转义，这样它就会具有特殊含义的元字符。

> 原义字符又叫做字面量字符（literal characters）。

注意：`\`本身也是元字符，使用它的原义也需要转义。

```javascript
var r1 = /java$/;
/*
	其中java就是原义字符，表示匹配包含java字符串
	$就是元字符，代表以某个字符结尾。该正则表达式
	表示匹配所有以java为结尾的字符串
*/
var r2 = /java\$/;	
//匹配包含java$的字符串
var r3 = /\\/;
//匹配包含\的字符串
```

#### 字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。

```js
var r1 = /[ab]/			//匹配包含a或者b字符的字符串
```

##### 脱字符

如果方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配。

```js
var r2 = /[^ab]/		//匹配不包含a或者b的字符串
```

如果方括号内没有其他字符，即只有`[^]`，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（`.`）是不包括换行符的。

```js
var s = 'Please yes\nmake my day!'

s.match(/yes.*day/) 		// null
s.match(/yes[^]*day/) 		// [ 'yes\nmake my day']
```

> 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

##### 连字符

某些情况下，对于连续序列的字符，连字符（`-`）用来提供简写形式，表示字符的连续范围。

```js
var r3 = /[a-z]/			//匹配包含a-z中任意一个字符的字符串
var r4 = /[a-zA-Z]/			//匹配包含a-z和A-Z任意一个字符的字符串
/[1-31]/					//匹配1-3，而不是1-32
/[-9]/						//匹配连字符和9，而不是0-9
```

注意：连字符（dash）只有当连字号用在方括号之中，才表示连续的字符序列。否则就不具备简写的作用，只代表字面的含义。

连字符还可以用来指定Unicode字符的范围。

```javascript
var str = "\u0130\u0131\u0132"	
/[\u0128-\uFFFF]/.test(str)	//true
```

另外不要过分使用连字符来设定一个很大的范围，否则就可能选中意料之外的字符。

```javascript
/[A-z]/.test('\\') 	// true
//本意是匹配大写字母A到小写字母z，但是由于在ASCII编码中
//大写字母与小写字母之间还有其它一些字符，例如反斜杠
```

#### 转义符

对于一些常用的字符类可以使用`\`转义原义字符，让其转换为元字符。

| 元字符 |       等价       | 说明                                                         |
| :----: | :--------------: | ------------------------------------------------------------ |
|   .    |     \[^\r\n]     | 匹配除回车(`\r`)、换行(`\n`)、行分隔符(`\u2028`)和段分隔符(`\u2029`)之外的所有字符。注意：对于对于码点大于`0xFFFF`字符，点字符不能正确匹配，会认为这是两个字符 |
|   \d   |      \[0-9]      | 匹配0-9之间的任一数字                                        |
|   \D   |     \[^0-9]      | 匹配所有0-9之外的字符                                        |
|   \s   | \[\t\n\x0B\f\r]  | 任何Unicode空白符，也就是匹配空格(包括制表符、空格符、断行符等) |
|   \S   | \[^\t\n\x0B\f\r] | 任何非Unicode空白符的字符，也就是匹配非空格的字符            |
|   \w   |   \[a-zA-Z0-9]   | 任何ASCII字符组成的单词，也就是匹配任意的字母、数字和下划线  |
|   \W   |  \[^a-zA-Z0-9]   | 任何非ASCII字符组成的单词，也就是匹配除了字母、数字和下划线之外的字符 |

当然`[]`内也可以使用以上元字符。

```javascript
var r = /[\d\s]/;	//匹配任意数字字符或空白字符
```

#### 特殊字符

还有一些其它的转义后的特殊元字符，这些特殊字符通常不能打印出来。

|   元字符    |                    说明                    |
| :------: | :--------------------------------------: |
|   `\t`   |         匹配水平制表符(\u0009)，也就是tab键          |
|   `\v`   |             匹配垂直制表符(\u000B)              |
|   `\n`   |           匹配换行符(\u000A)，也就是换行键           |
|   `\r`   |           匹配回车符(\u000D)，也就是回车键           |
|  `\o0`   |             匹配null字符(\u0000)             |
|   `\f`   |              匹配换页符(\u000C)               |
|  `\cX`   | 表示`Ctrl-[x]`，其中X是A-Z之中的任意一个英文字母，用来匹配控制字符 |
|  `[\b]`  |              匹配退格键(U+0008)               |
|  `\xhh`  |     匹配一个以两位十六进制数(`\x00`-`\xFF`)表示的字符     |
| `\uhhhh` | 匹配一个以四位十六进制数(`\u0000`-`\uFFFF`)表示的Unicode字符 |

```javascript
'ja    a'.replace(/\t/,"v");	//'java'
```

#### 边界字符

边界字符又称位置字符：

| 元字符  |   说明   |
| :--: | :----: |
|  ^   | 以xxx开始 |
|  $   | 以xxx结束 |
|  \b  |  单词边界  |
|  \B  | 非单词边界  |

#### 量词字符

在`{}`内加上量词用来表示某个字符重复的次数，或者使用特定的元字符也可以表示重复次数。具体如下：

| 元字符   | 说明                   |
| ----- | -------------------- |
| ?     | 匹配前一项0次或者1次，等价于{0,1} |
| +     | 匹配前一项1次或者多次，等价于{1,}  |
| *     | 匹配前一项0次或者多次，等价于{0,}  |
| {n}   | 匹配前一项n次              |
| {n,m} | 匹配前一项至少n次，但不能超过m次    |
| {n,}  | 匹配前一项n次或者更多次         |

注意：在使用元字符`*`和`?`时，它们允许匹配0个字符。

```javascript
var r1 = /\d\d/;	//匹配两个数字字符
var r2 = /\d{2}/;	//匹配两个数字字符
var r3 = /a?/;
r3.test("bb");		//true，"bb"中包含0个字符a
```

#### 选择符

使用`|`用于分隔供选择的字符。注意：选择项的匹配熟顺序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。

```javascript
var r = /ab|abc/;		//匹配ab字符或abc字符，而不是b字符或a字符，如果想要修改这个行为，可以使用括号
"abcd".replace(r,"x");			//"xcd"
"abcd".replace(/(ab|c)d/,"x");	//"abx"
```

### 贪婪模式

当使用量词来指定重复的次数时，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。

```js
"123456789".replace(/\d{3,6}/,"x"); 	//"x789"，贪婪模式
```

如果需要使用非贪婪匹配模式，只需要在量词或者表示重复次数的元字符后面加上`?`即可。

```javascript
"123456789".replace(/\d{3,6}?/,"x");	//"xxx"，非贪婪模式
```

但是使用非贪婪模式进行匹配时，运算结果可能和期望值不一样。例如：

```javascript
"aaab".replace(/a+b/,"x");	//"x"，贪婪模式
"aaab".replace(/a+?b/,"x");	//"x"，非贪婪模式
/*
	发现和期望匹配最后一个a和b字符不同。这是因为正则表达式的模式匹配
	总是会寻找字符串中第一个可能匹配的位置。
*/
```

### 分组

使用量词只能表示前一个字符的重复次数，如果需要表示多个字符的重复次数，则需要使用分组。正则表达式中，使用`()`把单独的项组合成子表达式，以便可以将其当做一个单元使用`|`、`*`、`+`或者`?`进行处理。

```javascript
var r1 = /abc{3}/;			//匹配三个c
var r2 = /a(bc){3}/;		//匹配三个dc
```

不仅如此，`()`的用处还有两个。其中一个就是在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。在后面的方法中会详细了解。

另一个用处就是允许在同一正则表达式的后部使用`\`加上数字引用前面的子表达式。其中数字表示字表达式在正则表达式中的位置。但是这个引用并不是对子表达式模式的引用，而是指的是那个模式相匹配的文本的引用。注意：嵌套的子表达式也会参与位置的计数。

```javascript
var r1 = /([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/;
//([Ss]cript)用\2表示，(fun\w*)用\3表示
var r2 = /('|")java\1/;				//匹配一个'或者"，\1表示它们总是成对
'"java"script'.replace(r2,"j");		//jscript
```

当然还允许不生成引用的数组，使用`(?:)`可以实现该功能。`?:`又称为非捕获组，表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

```javascript
var r2 = /(?:'|")java\1/;	//这样\1会失效	
```

### 前瞻

正则表达式在匹配字符串时总是从字符串头部开始，到尾部结束，因此字符串尾部方向又称为前。而前瞻就是当匹配到符合条件的字符时，向前检查断言部分的逻辑。其中正向前瞻或者肯定前瞻是符合断言的字符被匹配，而负向前瞻或者否定前瞻是不符合断言的字符被匹配。注意：**不会匹配断言字符。**

```javascript
var s = "m12v3vv";
s.replace(/\w(?=\d)/g,"x"); 	//"xx2x3vv"
//全局匹配单词字符并且断言符合数字字符的字符，正向前瞻
s.replace(/\w(?!\d)/,"x");		//"m1xv3vv"，无修饰符g
//匹配单词字符并且断言不符合数字字符的字符，负向前瞻。
```

同理向后检查断言部分的逻辑称为后顾，并且后顾也分为正向后顾和负向后顾。但是JavaScript并不支持后顾。

前瞻与后顾的语法如下：


| 名称                                          | 正则           |
| --------------------------------------------- | -------------- |
| 正向前瞻（又称先行断言，Positive look-ahead） | exp(?=assert)  |
| 负向前瞻（又称否定断言，Negative look-ahead） | exp(?!assert)  |
| 正向后顾                                      | exp(?<=assert) |
| 负向后顾                                      | exp(?<!assert) |

### 正则表达式实例方法

#### test()

`RegExp.prototype.test()`方法用来检测字符串中是否含有符合正则模式的子字符串，如果存在返回true，否则返回fase。

```js
let r1 = /\w/

r1.test("a") 		//true
r1.test("a") 		//true
r1.test("a") 		//true
```

如果正则表达式带有g修饰符，那么该方法会从上一次结束的位置开始向后匹配。

```js
let r2 = /\w/g

r2.test("ab") 		//true
r2.test("ab") 		//true
r2.test("ab") 		//false
```

你会发现当全局匹配时，结果发生了改变。这是因为当第一次匹配到"a"字符串，该字符串的最后一个字符的下一个位置是1(字符串索引从0开始)。并且每次查找时都会接着上次的lastIndex属性值的位置开始查找，直到返回false。并且此时lastIndex又会被重置为初始值0，重新查找，因此会出现循环的情况。

如果仅仅是为了不出现循环的情况，可以不本地化正则表达式来调用test()方法，但是并不推荐这样使用，因为每次实例化对象都会占用内存。

```js
(/\w/g).test("ab")			//true
(/\w/g).test("ab")			//true
(/\w/g).test("ab")			//true
```

当然，全局匹配时，你可以通过lastIndex属性来指定开始搜索的位置。

```javascript
var r = /x/g
var s = '_x_x'
r.lastIndex = 4
r.test(s) 			// false
```

#### exec()

`RegExp.prototype.exec()`方法用来返回匹配结果，如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。

```js
var s = '_x_x'
var r1 = /x/
var r2 = /y/

r1.exec(s) 		// ["x"]
r2.exec(s) 		// null
```

如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的`length`属性等于组匹配的数量再加1。

```js
var s = '_x_x'
var r = /_(x)/

r.exec(s) 				// ["_x", "x"]
```

另外，返回的结果数组还包含以下两个属性：

* input：整个原字符串
* index：整个模式匹配成功的开始位置

```js
var r = /a(b+)a/
var arr = r.exec('_abbba_aba_')

arr 			// ["abbba", "bbb"]

arr.index 		// 1
arr.input 		// "_abbba_aba_"
```

如果全局匹配模式下，则可以多次使用exec方法，下一次搜索位置从上一次匹配成功结束位置开始。

```js
var reg = /a/g;
var str = 'abc_abc_abc'

var r1 = reg.exec(str);
r1 							// ["a"]
r1.index 					// 0
reg.lastIndex 				// 1

var r2 = reg.exec(str);
r2 							// ["a"]
r2.index 					// 4
reg.lastIndex 				// 5

var r3 = reg.exec(str);
r3 							// ["a"]
r3.index 					// 8
reg.lastIndex 				// 9

var r4 = reg.exec(str);
r4						 	// null
reg.lastIndex 				// 0
```

全局匹配模式下，你也同样可以设置lastIndex属性值，来指定开始匹配的位置。

### 字符串实例方法

#### search()

该方法用来匹配字符串中符合正则表达式规则的子字符串，并且返回这个子字符串的首字符的索引值。如果不存在被匹配的子字符串则返回-1。注意：该方法也可以用于普通子字符串。

```javascript
var s = "a1b2";
s.search(/\d/g);		//1
'cat, bat'.search('at') // 1
```

注意：该方法不支持全局匹配，会忽略修饰符g，也就是说search()方法总是原字符串的第一个字符开始匹配，设置lastIndex属性无效。

#### match()

`String.prototype.match()`方法对字符串进行正则匹配，返回匹配结果。

```js
var s = '_x_x'
var r1 = /x/
var r2 = /y/

s.match(r1) 		// ["x"]
s.match(r2) 		// null
```

从结果可以看出，该方法和正则对象的exec()方法相似，匹配成功返回一个结果数组，失败则返回null。注意：这个结果数组同样拥有index和input属性。

和exec()方法不同的是，如果是全局匹配模式下，会一次性返回所有匹配成功的结果。

```js
var s = 'abba'
var r = /a/g

s.match(r) 			// ["a", "a"]
r.exec(s) 			// ["a"]
```

另外，设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。

```js
var r = /a|b/g
r.lastIndex = 7					//无效
'xaxb'.match(r) 				// ['a', 'b']
r.lastIndex 			    	// 0
```

当然该方法除了接收正则表达式为参数之外，还接收一个普通的字符串作为参数，并且同样返回原字符串中符合参数的子字符串(使用严格等于判断)数组。而如果没有匹配，则返回null。

```javascript
"hello".match("lo")								//["lo"]
"hello".match("x")								//null
'cat, bat, sat, fat'.match('xt')				// null
var matches = 'cat, bat, sat, fat'.match('at')
matches.index 									// 1
matches.input 									// "cat, bat, sat, fat"
```

注意：如果该方法中传入的正则表达式中包含分组时，不宜使用全局标识符`g`，否则match()方法不会捕获分组的内容。

```javascript
var m = 'abcabc'.match(/(.)b(.)/)
m									// ['abc', 'a', 'c']，会捕获
var m = 'abcabc'.match(/(.)b(.)/g)
m									// ['abc', 'abc']，不会捕获
```

#### split()

`String.prototype.split()`方法按照正则规则分割字符串，返回一个由分割的各个部分组成的数组。

> 注意：该方法会忽略全局标识符g

该方法接受两个参数，第一个参数是正则表达式，表示分割规则，第二个参数是返回数组的最大成员数。

```js
// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]
```

如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

```js
'aaa*a*'.split(/(a*)/)			// [ '', 'aaa', '*', 'a', '*' ]
```

#### replace()

`String.prototype.replace()`方法可以替换匹配的值，它接受两个参数，第一个是正则表达式，表示搜索模式；第二个是替换的内容。

如果正则表达式不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

```js
'aaa'.replace('a', 'b')			// "baa"
'aaa'.replace(/a/, 'b') 		// "baa"
'aaa'.replace(/a/g, 'b') 		// "bbb"
```

该方法的一个应用就是消除字符串首尾两端的空格。

```js
var str = '  #id div.class  '

str.replace(/^\s+|\s+$/g, '')	// "#id div.class"
```

该方法的第二个参数可以使用美元符号`$`，用来指代所替换的内容。

* `$&`：匹配的子字符串。
* `$``：匹配结果前面的文本。
* `$'`：匹配结果后面的文本。
* `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。
* `$$`：指代美元符号`$`。

```js
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')	// "world hello"

'abc'.replace('b', '[$`-$&-$\']')				// "a[a-b-c]c"
```

该方法的第二个参数还可以是一个函数，将每一个匹配的内容替换为函数返回值。

```js
'3 and 5'.replace(/[0-9]+/g, function (match) {
  return 2 * match;
})
// "6 and 10"

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.
```

作为`replace`方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。

```js
var prices = {
  'p1': '$1.99',
  'p2': '$9.99',
  'p3': '$5.00'
};

var template = '<span id="p1"></span>'
  + '<span id="p2"></span>'
  + '<span id="p3"></span>';

template.replace(
  /(<span id=")(.*?)(">)(<\/span>)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);
// "<span id="p1">$1.99</span><span id="p2">$9.99</span><span id="p3">$5.00</span>"
```











