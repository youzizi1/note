## 前端优化

**静态文件大小优化**

* JavaScript文件包括语法压缩（简写方法名和参数）和代码压缩（不必要的空白符和注释）
* CSS文件包括语法压缩（复合属性缩写，省略URL路径引号，省略值为0的单位）和代码压缩（注释和空白字符）

**书写和渲染优化**

* 结构：复合属性缩写；英文字体放在中文字体前面，中文字体最好使用`unicode`编码表示，已达到最好的兼容性；`font-weight`最好使用数字表示。

* 样式：选择器不宜嵌套过深；使用子选择器而不是用后代选择器；多利用继承；禁止使用通配符选择器
* 脚本：减少重绘和重流，如果非要进行DOM操作，可以将这个DOM元素单独作为一个图层；使用事件委托而不是每个子元素都绑定事件；操作DOM的时候要进行缓存；频繁触发回调的操作要使用节流和防抖

**图片优化**

* 图片文件压缩——构建工具或TinyPNG
* base64，本质上还是减少请求
* 雪碧图，本质上还是减少请求
* CSS替换简单的图标
* 图片懒加载——体验优化，滚动到可视区域再加载
* 浏览器支持的情况下使用webp格式的图片——无损压缩，体积小

**静态资源加载过程优化**

浏览器加载外部资源的特点：

* 每个域最多同时加载6个资源（http/1.1）
* CSS拥有最高优先级，即最先加载
* 只有等CSS都加载完了，才能加载其他资源，即使这个时候还没有达到6个限制

所以有如下优化方案：

* 静态资源放到不同的域名下
* CSS再head中引入，解决页面闪动问题——体验优化
* 使用defer异步脚本

**海量数据优化**

* 计算由worker线程来做
* 数据最好由后台分页

**webpack优化**

* 提高Node和Webpack的版本
* 尽量减少模块应用Loader。例如：打包JavaScript模块时，要配置exclude
* 合理使用sourceMap
* 控制包大小。例如：使用tree-shaking去掉冗余代码以及使用split chunk进行代码分割
* 拆分开发环境以及生产环境配置
* 结合stats分析打包结果
* 通过dllPlugin进行打包优化
* 开启Tree Shaking
* 开启noParse
* 开启ignorePlugin
* 开启多线程打包

**Vue优化**

* data中只存放与视图有关的数据
* data上的数据如果只是静态数据，可以使用`Object.freeze`
* spa页面使用`keep-alive`
* 组件拆分，减少不必要的渲染
* `key`保证唯一性
* 路由懒加载和异步组件
* 第三方模块按需加载

**React优化**

* 尽量使用函数组件
* 使用`shouldComponentUpdate`
* 使用`immutable`

**体验优化**

* 骨架屏
* `PWA`

**seo优化**

* 预渲染
* `SSR`

## 后端优化

**SSR**

* 首页开启服务器端渲染

## 网络优化

**减少HTTP请求**

* 雪碧图
* 静态资源合并

**CDN**

* 使用CDN

**缓存**

* 使用HTTP缓存

**文件大小**

* 静态文件使用gzip压缩

**DNS**

* 减少DNS查询，即DNS缓存

**避免重定向**

* 避免重定向，因为无论哪种类型重定向意味着多一次请求



